# :ledger: 코드 품질

## :one: Chrome으로 디버깅하기

`디버깅(debugging`은 스크립트 내 에러를 검출해 제거하는 일련의 과정을 의미한다. 모던 브라우저와 호스트 환경 대부분은 개발자 도구 안에 UI 형태로 디버깅 툴을 구비해 놓으며, 해당 툴을 사용하면 디버깅이 훨씬 쉬워지고 실행 단계마다 어떤 일이 일어나는지를 코드 단위로 추적이 가능하다.

### 1.1 소스(Sources) 패널

![debugging-sources-image](https://github.com/user-attachments/assets/e48a2832-0bdd-4535-b18b-fa347d521a10)

`소스(Sources) 패널`은 크게 세 개의 영역으로 구성된다.

1. **_파일 탐색 영역_**: 페이지를 구성하는 데 쓰인 모든 리소스를 트리 형태로 보여준다.
2. **_코드 에디터 영역_**: 리소스 영역에서 선택한 파일의 소스 코드를 보여준다.
3. **_자바스크립트 디버깅 영역_**: 디버깅에 관련된 기능을 제공한다.

### 1.2 중단점(breakpoint)

`중단점(breakpoint)`은 자바스크립트의 실행이 중단되는 코드 내 지점을 의미한다. 중단점을 이용하면 <u>실행이 중지된 시점에 변수가 어떤 값을 담고 있는지</u> 알 수 있으며 실행이 중지된 시점을 기준으로 명령어를 실행할 수 있다.

![debugging-breakpoint-image](https://github.com/user-attachments/assets/acadfee5-c8e3-48ed-8556-6df903b4757e)

위의 이미지와 같이, 소스 패널에서 코드의 라인을 클릭하면 우측에서 중단점을 확인할 수 있으며, 코드가 실행될 때 어떤 값을 담고 있는지 확인할 수 있다.

#### 1.2.1 조건부 중단점

줄 번호에 커서를 옮긴 후 마우스 오른쪽 버튼을 클릭하면 `조건부 중단점`을 설정할 수 있다. `Add conditional breakpoint`를 클릭했을 때 뜨는 작은 창에 표현식을 입력하면, 표현식이 **참인 경우**에만 실행을 중지시킬 수 있다. 조건부 중단점을 설정하면 <u>변수에 특정 값이 할당될 때나 함수의 매개 변수에 특정 값이 들어올 때만 실행을 중단</u>시킬 수 있어 디버깅 시 유용하게 활용할 수 있다.

### 1.3 debugger 명령어

`debugger` 명령어를 사용하면 브라우저를 켜 개발자 도구를 열고 소스 코드 영역을 띄워 중단점을 설정할 필요가 없어진다. 에디터를 떠나지 않고 중단점을 설정할 수 있기에 편리하다.

```javascript
function hello(name) {
  let phrase = `Hello, ${name}!`;

  debugger; // <-- 여기서 실행이 멈춥니다.

  say(phrase);
}
```

### :fire: Chrome으로 디버깅하기 회고

디버깅을 많이 사용한 기억은 없다. 하지만 같이 프로젝트를 진행했을 때 문제가 어느 지점에서 발생하는지 찾을 때 유용했던 기억이 있고, 개발자 도구보다는 `debugger` 명령어를 사용한 것이 조금 더 편리했다.

#### :pushpin: 참고 문서

- [ko.javascript.info - Chrome으로 디버깅하기](https://ko.javascript.info/debugging-chrome)
- [Chrome DevTools](https://developer.chrome.com/docs/devtools?hl=ko)

## :two: 코딩 스타일

개발자는 <u>간결하고 읽기 쉽게 코드를 작성</u>하는 것이 중요하다. 복잡한 문제를 간결하고 읽기 쉬운 코드로 작성해 해결하는 것이야말로 좋은 코드 스타일이며 어떤것들이 있는지 알아보자.

### 2.1 좋은 코드 스타일의 특징

1. **가독성**: 코드의 목적과 동작이 명확히 드러나야 한다.
2. **일관성**: 프로젝트 내 모든 코드가 통일된 스타일을 따라야 한다.
3. **유지보수성**: 다른 개발자가 쉽게 이해하고 수정할 수 있어야 한다.

#### 2.1.1 예시

```javascript
// 가독성이 좋은 코드
function getUserAge(user) {
  return user.age;
}

// 가독성이 떨어지는 코드
function gua(u) {
  return u.a;
}
```

### 2.2 코드 스타일을 관리하는 방법

#### 2.2.1 규칙의 중요성

**코드 스타일에 대한 "정답"은 없다.** 프로젝트 또는 팀의 컨벤션에 따라 스타일을 정의하고 이를 따르는 것이 중요하며 스타일을 팀원들과 명확히 합의하면 협업이 더 쉬워진다

#### 2.2.2 Linter 사용

Lint 도구를 활용하면 스타일 가이드를 자동으로 준수할 수 있다. `Linter`는 코드에서 발생할 수 있는 문제를 사전에 경고하거나 수정 제안을 제공한다.

### 2.3 추천 도구

아래는 자바스크립트에서 널리 사용되는 `Linter` 도구들이다.

- [ESLint](https://eslint.org/)
  - 최신 Linter로 확장성과 유연성이 뛰어남.
  - 다양한 플러그인과 규칙 설정을 지원하며, 가장 많이 사용되는 도구이다.
- [Prettier](https://prettier.io/)
  - 코드 포맷팅에 특화된 도구로, 일관된 스타일을 유지함.
  - ESLint와 함께 사용하면 서로 보완하여 완벽한 코드 스타일을 유지할 수 있다.

프로젝트를 하며 둘 다 가장 많이 사용했으며, 협업할 때 들여쓰기, 세미콜론 등 각자 스타일이 다르지만 해당 도구를 사용하면 모두 통일된 스타일을 맞출 수 있어서 정말 유용하다.

### :fire: 회고

좋은 코드 스타일을 유지하려면 `ESLint`와 `Prettier`를 적극적으로 활용하고, 팀 컨벤션을 준수하는 것이 중요핟다. 이 두 가지 도구를 통해 일관성 있고 가독성 높은 코드를 작성해보자

#### :pushpin: 참고 문서

- [ko.javascript.info - 코딩 스타일](https://ko.javascript.info/coding-style)

## :three: 주석

주석은 어떻게 코드가 동작하는지, 왜 코드가 동작하는지를 설명하는데 사용된다. 주석은 정해진 방식이 없다보니 대부분 각자의 방식으로 작성하는데(사실 본인 ㅠㅠ) 잘 작성된 주석도 있으면 잘못된 방법의 주석도 있으며 어떤것들이 있는지 알아보자

### 3.1 좋은 주석이란 무엇인가?

주석에서 설명이 담긴 주석은 대개 좋지 않다고 한다. 그렇다면 좋은 주석이란 무엇인지 알아보자.

- 간결하면서도 명확한 정보를 제공하는 주석.
- 중복되거나 불필요하지 않은 주석.
- 현재 코드와 일치하는 최신 상태의 주석.
- 아키텍처를 설명하는 주석.
- 함수 용례와 매개변수 정보를 담고 있는 주석.

#### 3.1.1 TODO, FIXME 태그 사용

개선해야 할 부분이나 버그를 명시적으로 기록한다.

```javascript
// TODO: 향후 성능 최적화를 위해 debounce 함수 추가 필요
function handleInput(event) {
  console.log(event.target.value);
}
```

#### 3.1.2 필요한 경우에만 작성

코드 자체로 의도가 명확한 경우 주석은 불필요함.

```javascript
// Bad: 주석이 불필요한 경우
x = x + 1  # x 값을 1 증가시킴

// Good: 코드만으로도 충분히 이해 가능
x += 1
```

### 3.2 나쁜 주석이란 무엇일까?

위의 예시와 반대로 생각하면 될 것 같다. 내용은 아래와 같다.

- `중복된 주석`: 코드와 동일한 내용을 설명하는 주석.
- `오래된 주석`: 코드가 변경되었지만, 주석이 업데이트되지 않은 경우.
- `모호한 주석`: 불분명하거나 오히려 혼란을 주는 주석.

### 3.3 주석 작성 요령

최대한 주석을 사용하지 않도록 변수와 함수 등을 통해 이해할 수 있게 작성하며, 팀 내에서 주석 작성 규칙을 합의하고 일관성을 유지하자. 만약, 주석이 너무 길어지거나 코드의 흐름을 방해하는 경우 별도의 문서로 정리하는 방법을 생각해보자.

#### 3.3.1 코드 리뷰에서 주석 검토

PR(풀 리퀘스트) 리뷰 시 주석도 코드처럼 검토.

#### 3.3.2 주석 스타일 가이드 사용

팀 내에서 주석 작성 규칙을 합의하고 일관성을 유지.

#### 3.3.3 주석 대신 의미 있는 이름 사용

주석 없이도 코드가 이해되도록 변수명, 함수명, 클래스명을 명확히 설정.

### :fire: 회고

이전에 함수를 만들 때 어떤 함수인지 어떻게 동작하는지 주석을 달았던 적이 있는데, 이번 공부를 통해 오히려 <u>코드가 어떻게 동작하는지, 무엇을 하는지</u>에 대한 주석은 좋지 않다라는 것을 새롭게 알게 되었다. 최대한 변수, 함수명에서 의도를 전달하도록 설명이 꼭 필요한 경우와 길 경우 다른 방법으로 팀원에게 공유하는 방식을 찾아보는것도 좋은 것 같다.

#### :pushpin: 참고 문서

- [ko.javascript.info - 주석](https://ko.javascript.info/comments)

## :four: 닌자 코드

읽기 어렵고 유지보수성이 낮은 코드를 `닌자 코드`라고 비유한다. 이러한 코드 작성 방식에 대해 간단히 알아보고 반대의 클린 코드는 무엇인지 알아보자.

### 4.1 닌자 코드 예시

닌자 코드는 작성자 본인만 이해할 수 있는 코드로, 일반적으로 다음과 같은 특징을 가진다

- 의미 없는 변수명
- 길고 복잡한 함수
- 주석 부족 또는 부적절한 주석
- 비직관적인 로직

```javascript
// 함수명 x와 변수명 a, b는 의미가 모호함.
function x(a) {
  let b = [];
  for (let i = 0; i < a.length; i++) {
    if (a[i] % 2 === 0) {
      b.push(a[i]);
    }
  }
  return b;
}

console.log(x([1, 2, 3, 4, 5, 6]));
```

위 코드는 암호화를 위한 로직으로 보일 수 있지만, 변수명이나 로직이 명확하지 않아 코드를 이해하기가 어렵다.

### 4.2 클린 코드 예시

클린 코드는 읽기 쉽고 유지보수하기 용이하며, 협업에 적합한 코드를 의미한다. 클린 코드를 작성하기 위한 기본 원칙은 다음과 같다.

- 의미 있는 변수명 사용
- 짧고 명확한 함수 작성
- 적절한 주석 작성
- 일관된 코드 스타일
- 직관적인 로직 구현

```javascript
// 함수명 filterEvenNumbers와 변수명 numbers, evenNumbers는 함수의 의도와 역할을 명확히 전달한다.
function filterEvenNumbers(numbers) {
  const evenNumbers = [];

  for (let i = 0; i < numbers.length; i++) {
    if (numbers[i] % 2 === 0) {
      evenNumbers.push(numbers[i]);
    }
  }

  return evenNumbers;
}

console.log(filterEvenNumbers([1, 2, 3, 4, 5, 6])); // [2, 4, 6]
```

### 4.3 닌자 코드가 발생하는 이유는 뭘까?

1. `시간 압박`: 빠른 개발을 위해 코드 가독성을 희생할 때 발생할 것 같다.
2. `코딩 습관`: 설계와 문서화보다는 빠른 결과를 중시하는 경우 (경험도 있었던 것 같은..)
3. `경험 부족`: 가독성이나 유지보수성의 중요성을 인식하지 못한 상태에서 작성. (역시 나..!)

#### 4.4 클린 코드를 잘 작성하려면?

- `[SOLID 원칙](https://f-lab.kr/insight/understanding-and-applying-solid-principles?gad_source=1&gclid=Cj0KCQiAx9q6BhCDARIsACwUxu6Q_BaKuJvnW2fW8dZUWeIJ9N4ioW0dyEaciSFqZuwPY_EkUYjXQYUaArJkEALw_wcB) 준수`: 객체지향 설계의 5가지 원칙을 따르기.
- `리팩토링`: 주기적으로 코드 개선 작업 수행.
- `테스트 작성`: 기능을 검증하고 코드 품질을 유지.
- `리뷰 요청`: 다른 개발자와 코드 리뷰를 통해 개선.

### :fire: 회고

닌자 코드와 클린 코드는 단순히 코드를 작성하는 방식만이 아니라, 개발자의 사고방식과 작업 스타일을 반영한다. 읽기 쉽고 유지보수하기 쉬운 코드를 작성하면 팀 전체의 생산성이 향상될 뿐만 아니라 프로젝트 또한 성공적으로 마무리할 확률이 높을 것 같다.

#### :pushpin: 참고 문서

- [ko.javascript.info - 닌자 코드](https://ko.javascript.info/ninja-code)

## :five: 테스트 자동화와 Mocha

테스트 자동화는 개발 과정에서 뿐만 아니라 현업에서도 효율성과 품질 향상을 위해 필수적으로 사용된다. 테스트의 중요성과 이를 효율적으로 관리할 수 있는 테스트 자동화 도구인 `Mocha`를 중심으로 알아보자.

### 5.1 테스트는 왜 해야 하는가?

함수를 구현할 때, 우리는 일반적으로 매개변수와 결과 간의 관계를 구상하면서 코드를 작성한다. 작성한 코드가 의도한 대로 동작하는지 확인하기 위해 보통 콘솔 로그나 간단한 출력 테스트를 사용하는데, 이런 수동적인 테스트 방식은 다음과 같은 문제점을 갖고 있다.

#### 5.1.1 수동 테스트는 시간이 많이 든다.

- 매번 코드를 수정할 때마다 이전의 모든 유스 케이스를 수동으로 테스트해야 한다.
- 테스트 범위가 늘어날수록 확인해야 할 시나리오가 기하급수적으로 증가한다.

#### 5.1.2 테스트 누락 가능성이 높다.

- 특정 케이스(f(1), f(2))는 확인했지만, 코드 수정 후 이전에 동작하던 케이스를 다시 검증하지 않을 수 있다.
- 특히 협업 환경에서는 다른 개발자가 추가한 기능이 기존의 동작을 깨트릴 위험이 크다.

#### 5.1.3 유지보수가 어렵다.

- 시간이 지나면 어떤 조건에서 테스트를 진행했는지 기억하기 어렵다.
- 개발자는 새로운 기능에 집중하다 보니 이전 기능을 간과할 가능성이 크다.

### 5.2 테스트 자동화의 필요성

테스트 자동화는 이런 문제를 해결하는 데 핵심적인 역할을 한다. 자동화된 테스트 코드를 작성하면 다음과 같은 장점이 있음.

#### 5.2.1 반복 가능한 테스트

- 모든 유스 케이스를 빠짐없이 재검증할 수 있다.
- 한 번 작성한 테스트 코드는 언제든 재사용 가능하므로 유지보수 시 큰 도움을 준다.

#### 5.2.2 신뢰할 수 있는 코드

- 코드 변경 후에도 기존 기능이 깨지지 않았음을 자동으로 확인할 수 있다.
- 협업 시 다른 개발자가 새로운 기능을 추가하더라도 전체 코드의 안정성을 유지할 수 있음.

#### 5.2.3 빠른 피드백

- 코드 작성 후 바로 테스트를 실행해 결과를 확인할 수 있음.
- 버그를 초기에 발견할 수 있어 개발 속도를 높이고, 디버깅 비용을 줄여준다.

### 5.3 Mocha를 활용한 테스트 자동화

[Mocha](https://mochajs.org/)는 Node.js 환경에서 널리 사용되는 JavaScript 테스트 프레임워크다. 간단한 설정으로 빠르게 테스트를 자동화할 수 있어 인기 있는 도구 중 하나다.

#### 5.3.1 Mocha의 주요 특징

- `유연한 테스트 작성`
  - BDD(Behavior Driven Development)와 TDD(Test Driven Development) 스타일을 모두 지원한다.
- `다양한 Assertion Library 지원`
  - 기본 제공하지 않지만, [Chai](https://www.chaijs.com/)와 같은 라이브러리를 함께 사용할 수 있다.
- `비동기 테스트 지원`
  - async/await이나 콜백을 사용하는 비동기 코드 테스트에 적합하다.

#### 5.3.2 Mocha 예제 코드

간단한 덧셈 함수를 테스트하는 코드로 아래의 예시를 확인해보자.

```javascript
// 덧셈 함수
function add(a, b) {
  return a + b;
}
module.exports = add;

// 테스트 코드 (test.js)
const assert = require("chai").assert;
const add = require("../add");

describe("Add Function", () => {
  it("should return 5 when adding 2 and 3", () => {
    const result = add(2, 3);
    assert.equal(result, 5);
  });

  it("should return 0 when adding 0 and 0", () => {
    const result = add(0, 0);
    assert.equal(result, 0);
  });

  it("should handle negative numbers correctly", () => {
    const result = add(-2, -3);
    assert.equal(result, -5);
  });
});
```

**_실행 방법_**

1. Mocha와 Chai 설치 (`npm install mocha chai --save-dev`)
2. 테스트 실행 (`npx mocha`)

### :fire: 회고

개인적으로 테스트 자동화는 작업시에 추가 작업처럼 느껴지고 시간이 더 든다고 생각하지만, 장기적으로 보았을 때 코드의 안정성과 확장성이 높아 협업에서 크게 도움이 될 거 같다고 생각이 들었다. 작은 단위의 프로젝트에서 사용하기에는 조금 불필요할 수 있지만 규모가 큰 프로젝트에서 큰 도움이 될 거라 생각한다.

#### :pushpin: 참고 문서

- [ko.javascript.info - 테스트 자동화와 Mocha](https://ko.javascript.info/testing-mocha)

## :six: 폴리필

프론트엔드 개발을 하다보면 `폴리필`, `바벨`, `트랜드파일러` 같은 용어를 접하게된다. 이 개념들이 무엇인지 어떤 역할을 하는지 알아보자

### 6.1 폴리필(Polyfill)란 무엇인가?

`폴리필`은 브라우저가 <u>특정 기능(메서드, API 등)을 지원하지 않을 때</u>, 이를 **흉내 내어 사용할 수 있도록 제공**하는 코드이다.

- 예를 들어, 오래된 브라우저는 최신 자바스크립트 표준에 정의된 `Array.prototype.includes()`를 지원하지 않을 수 있는데 폴리필을 사용하면 이 기능을 해당 브라우저에서도 사용할 수 있도록 만들어 준다.

#### 6.1.1 폴리필 예시

다음은 브라우저가 `includes` 메서드를 지원하지 않을 경우 사용할 수 있는 폴리필이다.

```javascript
if (!Array.prototype.includes) {
  Array.prototype.includes = function (element) {
    return this.indexOf(element) !== -1;
  };
}
```

#### 6.1.2 사용법

**Core-JS 설치**

```javascript
npm install core-js
```

**폴리필 추가**

```javascript
import "core-js/stable";
import "regenerator-runtime/runtime";
```

**_폴리필의 특징_**

- 브라우저의 호환성을 높이는 역할을 한다.
- 주로 구형 브라우저에서 최신 기능을 사용할 때 유용하다.
- [Core-JS](https://github.com/zloirock/core-js) 라이브러리가 대표적인 폴리필 모음집이다.

### 6.2 바벨(Babel)이란 무엇인가?

`바벨`은 최신 자바스크립트 코드를 구형 브라우저에서도 실행할 수 있도록 **변환(트랜스파일)하는 도구**다. 최신 문법을 이해하지 못하는 브라우저를 위해 코드를 변환해 준다.

#### 6.2.1 바벨의 필요성

- 최신 자바스크립트 문법은 오래된 브라우저에서 지원되지 않을 수 있다.
- 예를 들어, ES6의 let, const, arrow function 등의 문법은 IE11 같은 브라우저에서 실행되지 않음.
- 바벨은 이런 문법을 구형 브라우저에서도 동작하도록 ES5로 변환한다.

```javascript
// ES6 문법
const add = (a, b) => a + b;

// 바벨이 변환한 코드
var add = function (a, b) {
  return a + b;
};
```

### 6.3 트랜스파일러(Transpiler)란 무엇인가?

- 트랜스파일러는 코드의 한 프로그래밍 언어를 같은 수준의 다른 언어로 변환하는 도구다.
- 바벨도 트랜스파일러의 일종으로, 최신 자바스크립트를 과거 버전의 자바스크립트로 변환한다.

#### 6.3.1 트랜스파일러와 컴파일러의 차이

- `컴파일러`는 고급 언어(예: 자바)를 저급 언어(예: 머신 코드)로 변환한다.
- `트랜스파일러`는 동일한 수준의 언어(예: 최신 JS → 구 JS) 간의 변환을 수행한다.

### 6.4 폴리필과 바벨의 차이점

| 특징       | 폴리필                                      | 바벨                                    |
| ---------- | ------------------------------------------- | --------------------------------------- |
| 역할       | 특정 기능(API, 메서드)의 구현을 보충        | 최신 문법을 구 버전 자바스크립트로 변환 |
| 적용 대상  | 브라우저에서 동작하지 않는 기능             | 브라우저가 이해하지 못하는 새로운 문법  |
| 사용 사례  | Array.prototype.includes, Promise, fetch 등 | const, let, arrow functions, classes 등 |
| 라이브러리 | Core-JS 등                                  | Babel                                   |

### :fire: 회고

- 폴리필은 브라우저에서 부족한 기능을 보충하는 코드이다.
- 바벨은 최신 자바스크립트를 구형 브라우저에서도 실행 가능하도록 변환한다.
- 트랜스파일러는 바벨과 같은 도구를 포함하며, 언어 간의 호환성을 높이는 데 사용된다.

#### :pushpin: 참고 문서

- [ko.javascript.info - 폴리필](https://ko.javascript.info/polyfills)
