# **Chrome으로 디버깅하기**

## **디버깅(Debugging)**

**스크립트 내 에러를 검출해 제거하는 일련의 과정**

**f12를 눌러 chrome에서 개발자 도구를 열 수 있다.**

## **소스(sources) 패널**

![image](https://github.com/user-attachments/assets/1e4f5a21-7a1f-460d-b2b2-b792776f84bf)

1. **파일 탐색 영역 – 페이지를 구성하는 데 쓰인 모든 리소스(HTML, JavaScript, CSS, 이미지 파일 등)를 트리 형태로 보여준다. Chrome 익스텐션이 여기 나타날 때도 있다.**
2. **코드 에디터 영역 – 리소스 영역에서 선택한 파일의 소스 코드를 보여준다. 여기서 소스 코드를 편집할 수도 있다.**
3. **자바스크립트 디버깅 영역 – 디버깅에 관련된 기능을 제공한다.**

### **디버깅 영역의 하위 패널들**

1. **`Watch` – 표현식을 평가하고 결과를 보여줍니다.**
    
    **Add Expression 버튼 `+`를 클릭해 원하는 표현식을 입력한 후 Enter를 누르면 중단 시점의 값을 보여줍니다. 입력한 표현식은 실행 과정 중에 계속해서 재평가됩니다.**
    
2. **`Call Stack` – 코드를 해당 중단점으로 안내한 실행 경로를 역순으로 표시합니다.**
    
    **실행은 `index.html` 안에서 `hello()`를 호출하는 과정 중에 멈췄습니다. 함수 `hello` 내에 중단점을 설정했기 때문에, 콜 스택(Call Stack) 최상단엔 `hello`가 위치합니다. `index.html`에서 함수 `hello`를 정의하지 않았기 때문에 콜 스택 하단엔 'anonymous’가 출력됩니다.**
    
    **콜 스택 내의 항목을 클릭하면 디버거가 해당 코드로 휙 움직이고, 변수 역시 재평가됩니다. 'anonymous’를 클릭해 직접 확인해 봅시다.**
    
3. **`Scope` – 현재 정의된 모든 변수를 출력합니다.**
    
    **`Local`은 함수의 지역변수를 보여줍니다. 지역 변수 정보는 소스 코드 영역에서도 확인(강조 표시)할 수 있습니다.**
    
    **`Global`은 함수 바깥에 정의된 전역 변수를 보여줍니다.**
    
    **`Local` 하위 항목으로 `this`에 대한 정보도 출력되는데, 이에 대해선 추후에 학습하도록 하겠습니다.**
    

## **콘솔**

**콘솔란에 Javascript 구문(state)을 입력하고 실행할 수 있다.**

![image](https://github.com/user-attachments/assets/c25d9b5a-b5e1-4d86-a328-daaad79112b2)


## **중단점**

![image](https://github.com/user-attachments/assets/7a357b33-94c9-44c5-845e-18f644d0bb38)


**`hello.js` 스니펫을 만든 뒤 3번 줄과 7번줄의 번호를 클릭하여 중단점으로 만든다. 그러면 오른쪽에 중단점 목록에 보이게 된다.**

**중단점이란 말 그대로 자바스크립트의 실행이 중단 되는 코드 내의 지점을 말한다.**

**오른쪽의 리스트를 클릭하면 해당 코드로 이동이 가능하다.**

## **debugger 명령어**

```jsx
function hello(name) {
  let phrase = `Hello, ${name}!`;

  debugger;  // <-- 여기서 실행이 멈춥니다.

  say(phrase);
}
```

**`debugger` 명령어를 사용하면 브라우저를 따로 열지 않고도 중단점을 만들 수 있다.**

## **console.log**

**`console.log` 함수를 이용하면 원하는 것을 콘솔로 출력할 수 있다.**

```jsx
for (let i = 0; i < 5; i++) {
  console.log("숫자", i);
}
```

## **script 실행이 중단되는 경우**

1. **중단점을 만날 때**
2. **debugger문을 만날 때**
3. **에러가 발생했을 때(개발자 도구가 열려있고 실행 중 버튼이 활성화 되어있는 경우)**

# [**디버깅 잘하는 16가지 방법**](https://raygun.com/learn/javascript-debugging-tips)

1. **`debugger`문 사용하기**
코드에 `debugger;` 줄을 넣으면 Chrome이 실행될 때 자동으로 그 줄에서 멈춘다. 조건문으로 감싸서 필요할 때만 실행되도록 할 수도 있다.
    
    ```jsx
    if (condition) {    
    	debugger;
    }
    ```
    
2. **객체를 테이블로 출력하기**
    
    복잡한 객체를 확인할 때에는 console.log()를 통해서 볼 수도 있지만 console.table()을 통해서 더 쉽게 확인할 수 있다.
    
    ```jsx
    var animals = [
        { animal: 'Horse', name: 'Henry', age: 43 },
        { animal: 'Dog', name: 'Fred', age: 13 },
        { animal: 'Cat', name: 'Frodo', age: 18 }
    ];
     
    console.table(animals);
    ```
    
    ![image](https://github.com/user-attachments/assets/091b86ab-af8b-4976-ada9-51ef86a10b92)

    
3. **개발자 도구 기기 모드 전환 버튼 사용하기**
    
    모든 모바일 기기를 체크해 볼 수 없지만 뷰포트의 크기를 조절하는 것은 가능하다. Chrome에서 모든 기능을 제공하기 때문에 개발자 도구에서 기기 모드 전환 버튼을 클릭하여 미디어 쿼리를 확인할 수 있다.
    ****
    
    ![image](https://github.com/user-attachments/assets/25b7fc03-be47-4928-8ea3-6bb9f2650c3c)

    
4. **DOM 요소 빠르게 찾는 법**
요소(element) 패널에서 DOM 요소를 표시하고 콘솔에서 사용한다. 크롬 인스펙터는 마지막 5개 요소를 기록에 유지하므로 마지막 표시된 요소는 $0, 두 번째부터 마지막 표시된 요소는 $1로 표시되는 등의 방식으로 표시된다. 'item-4′, 'item-3', 'item-2', 'item-1', 'item-0' 순서로 다음 항목을 표시하면 콘솔에서 이와 같이 DOM 노드에 액세스할 수 있다
****
    
    ![image](https://github.com/user-attachments/assets/aa5ab150-2b28-4548-8f49-d674ce4c1b2b)

    
5. **`console.time()` 과 `console.timeEnd()` 를 사용하여 반복문 벤치마크 하기**
특히 느린 반복문을 디버깅할 때 실행하는 데 걸린 시간을 정확히 알면 매우 유용할 수 있다.
메서드에 레이블을 지정하여 여러 타이머를 설정할 수도 있다.
    
    ```jsx
    console.time('Timer1');
     
    var items = [];
     
    for(var i = 0; i < 100000; i++){
       items.push({index: i});
    }
     
    console.timeEnd('Timer1');
    ```
    
    ![image](https://github.com/user-attachments/assets/959eafe8-abb9-44a6-9b69-d8afbc258763)

    
6. **함수에 대한 스택 추적 가져오기**
자바스크립트는 구조화된 언어가 아니기 때문에 어떤 일이 언제 일어났는지 파악하기 어려울 때가 있다. 이럴 때 console.trace(또는 콘솔의 추적)를 사용하면 JavaScript를 디버깅하는 데 유용하게 사용할 수 있다. 33줄의 자동차 인스턴스에서 함수 호출 funcZ에 대한 전체 스택 추적을 보고 싶다고 가정해 보겠습니다:
    
    ```jsx
    var car;
    var func1 = function() {
    	func2();
    }
    
    var func2 = function() {
    	func4();
    }
    var func3 = function() {
    }
    
    var func4 = function() {
    	car = new Car();
    	car.funcX();
    }
    var Car = function() {
    	this.brand = ‘volvo’;
    	this.color = ‘red’;
    	this.funcX = function() {
    		this.funcY();
    	}
    
    	this.funcY = function() {
    		this.funcZ();
    	}
    
    	this.funcZ = function() {
    		console.trace(‘trace car’)
    	}
    }
    func1();
    var car; 
    var func1 = function() {
    	func2();
    } 
    var func2 = function() {
    	func4();
    }
    var func3 = function() {
    } 
    var func4 = function() {
    	car = new Car();
    	car.funcX();
    }
    var Car = function() {
    	this.brand = ‘volvo’;
    	this.color = ‘red’;
    	this.funcX = function() {
    		this.funcY();
    	}
    	this.funcY = function() {
    		this.funcZ();
    	}
     	this.funcZ = function() {
    		console.trace(‘trace car’)
    	}
    } 
    func1();
    ```
    
    ![image](https://github.com/user-attachments/assets/d2e7626e-86f1-495d-97a7-3d585ac5b020)

    
    위 사진 처럼 `trace`를 통해 `funcZ`가 어디서부터 실행되었는지 추적이 가능하다
    
7. **디버그하기 쉽게 코드를 압축 해제해서 보기**
가끔 프로덕션 환경에서 문제가 발생하여 소스 맵이 서버에 제대로 전달되지 않는 경우가 있다. Chrome은 자바스크립트 파일을 사람이 읽기 쉬운 형식으로 압축 해제할 수 있다. 이 코드는 실제 코드만큼 유용하지는 않지만 최소한 어떤 일이 일어나고 있는지 확인할 수 있니다. 인스펙터의 소스 뷰어 아래에 있는 {} 예쁘게 인쇄 버튼을 클릭해서 가져갈 수 있다.
    
    ![image](https://github.com/user-attachments/assets/fce1962f-e141-41e1-9fea-f43f62327413)

    
8. **디버깅할 함수 빠르게 찾기**
   
    ‍1. 인스펙터에서 해당 줄을 찾아 중단점을 추가  
    2. 스크립트에 디버거 추가하기
    
    ![image](https://github.com/user-attachments/assets/28fb470d-b1b2-4c3e-b713-23fd0dcc0868)

    
9. **관련이 없는 블랙박스 스크립트**
디버깅할 필요가 없는 스크립트를 블랙박스화한다.
블랙박스 테스트: 
• **`블랙박스 테스트(Black Box Test)`**는 소프트웨어가 수행할 특정 기능을 알기 위해 각 기능이 완전히 작동되는 것을 입증하는 테스트로 **기능 테스트**라고도한다. 즉, 입력값과 출력값만을 확인하는 테스트이다.
10. **복잡한 디버깅에서 중요한 사항 찾기**
더 복잡한 디버깅에서는 때때로 많은 줄을 출력하고 싶을 때가 있다. 출력의 구조를 더 잘 유지하기 위해 할 수 있는 한 가지 방법은 콘솔 함수를 더 많이 사용하는 것이다. 그 다음 인스펙터에서 필터링할 수 있다. 원하는 경우 창의력을 발휘하여 메시지에 스타일을 지정할 수 있다. 자바스크립트를 디버깅하고 싶을 때 CSS를 사용하여 자신만의 구조화된 콘솔 메시지를 만들 수 있다
    
    ```jsx
    console.todo = function(msg) {
        	console.log(‘ % c % s % s % s‘, ‘color: yellow; background - color: black;’, ‘–‘, msg, ‘–‘);
    }
     
    console.important = function(msg) {
        	console.log(‘ % c % s % s % s’, ‘color: brown; font - weight: bold; text - decoration: underline;’, ‘–‘, msg, ‘–‘);
    }
     
    console.todo(“This is something that’ s need to be fixed”);
    console.important(‘This is an important message’);
    ```
    
    ![image](https://github.com/user-attachments/assets/4e70095a-c199-4b49-aeaf-a3b770e39b24)

    
11. **특정 함수 호출 및 인수 보기**
Chrome 콘솔에서 특정 함수를 계속 주시할 수 있다. 함수가 호출될 때마다 전달된 값과 함께 로그에 기록된다.
    
    ```jsx
    var func1 = function(x, y, z) {
    //....
    };
    ```
    
    ![image](https://github.com/user-attachments/assets/7fd6c85d-cfa0-4fad-abeb-bef3a676a6bf)

    
12. **콘솔의 요소에 빠르게 액세스**
콘솔에서 `querySelector` 를 더 빠르게 수행할 수 있는 방법은 `$` 기호를 사용하는 것이다. `$` 하나는 첫 번째 일치 항목을 반환하고 두 개는 모든 일치 항목을 반환한다.
    
    ![image](https://github.com/user-attachments/assets/fb66dacb-0b54-41aa-a1d7-8011ffda676d)

    
13. **Postman 사용하기 (하지만 Firefox가 더 빠름)**
Postman을 통해서 Ajax 요청을 확인 할 수 있다. 하지만 새 브라우저 창을 열고 새 요청 객체를 작성하고 테스트하는 것이 번거로울 수 있다. FireFox에서는 개발자 도구를 통해 요청을 편집하고 다시 보낼 수 있다.
14. **노드 변경 시 중단**
자바스크립트를 디버깅해야 할 때 Chrome에서는 DOM 요소가 변경될 때 일시정지할 수 있다. 해당 속성을 모니터링할 수도 있다. Chrome Inspector에서 요소를 마우스 오른쪽 버튼으로 클릭하고 사용할 휴식 시간 설정을 선택한다.
    
    ![image](https://github.com/user-attachments/assets/62eaa620-5cda-411f-9882-c553aba98792)

    
15. **페이지 속도 체크 서비스 사용**
페이지의 JavaScript를 감사하고 속도 저하나 문제를 찾는 데 사용할 수 있는 서비스와 도구는 시중에 많이 나와 있다. 이러한 도구 중 하나가 Raygun 실제 사용자 모니터링이다. 이 도구는 자바스크립트 문제를 찾는 것 외에도 느리게 로드되는 외부 스크립트, 불필요한 CSS, 크기가 큰 이미지 등 다른 이유에서도 유용하게 사용할 수 있다. 의도치 않게 로딩 시간이 길어지거나 제대로 실행되지 않는 JavaScript 문제를 파악하는 데 도움이 될 수 있다. 또한 JavaScript 성능의 개선 사항을 측정하고 시간 경과에 따라 추적할 수 있다.
16. **모든 곳에 중단점 생성하기**
    
    요소를 클릭하고 중단점을 설정하여 특정 요소가 수정될 때 실행을 중지할 수 있다. 
    
    개발자 도구의 디버거 탭 또는 소스 탭(브라우저에 따라 다름)으로 이동하여 특정 소스에 대한 XHR 중단점을 설정하여 Ajax 요청이 중지되도록 할 수도 있다. 
    
    같은 위치에서 예외가 발생할 때 코드 실행을 일시 중지하도록 설정할 수도 있다. 
    
    개발자 도구에서 다양한 종류의 중단점을 사용하면 외부 툴에 투자할 필요 없이 버그를 발견할 가능성을 극대화 할 수 있다.
    

# 코딩 스타일

좋은 코드 → 간결하고 읽기 쉬운 코드

## 모던 JS 튜토리얼에서 추천하는 규칙

- 매개변수 사이에 공백 한 칸 씩
- 함수 이름과 괄호 및 인자 사이에는 공백 없음
- 공백 2칸으로 들여쓰기
- for/if/while… 뒤에 공백 한 칸씩
- } else { 줄바꿈 없이
- 중첩된 호출 앞뒤에 공백 한 칸씩
- 논리적으로 다른 블록은 한 줄 띄어쓰기
- 한 줄은 너무 길지 않게
- 세미콜론 ; 필수
- 연산자 앞뒤에 공백 한 칸씩
- 중괄호는 앞에 공백 한 칸을 두고 같은 줄에 작성
- 인수 사이에 공백 한 칸

## 함수의 위치

‘헬퍼’ 함수 여러 개를 만들어 사용하고 있다면 아래와 같은 방법을 사용해 코드 구조를 정돈할 수 있다.

1. 헬퍼 함수를 사용하는 코드 위에서 헬퍼 함수를 모아 선언하기
    
    ```jsx
    // 함수 선언
    function createElement() {
      ...
    }
    
    function setHandler(elem) {
      ...
    }
    
    function walkAround() {
      ...
    }
    
    // 헬퍼 함수를 사용하는 코드
    let elem = createElement();
    setHandler(elem);
    walkAround();
    ```
    
2. 코드를 먼저, 함수는 그 다음에 선언하기
    
    ```jsx
    // 헬퍼 함수를 사용하는 코드
    let elem = createElement();
    setHandler(elem);
    walkAround();
    
    // --- 헬퍼 함수 ---
    function createElement() {
      ...
    }
    
    function setHandler(elem) {
      ...
    }
    
    function walkAround() {
      ...
    }
    ```
    
3. 혼합: 코드 바로 위에서 필요한 함수 그때그때 선언하기

보통 두 번째 방법으로 코드를 정돈하는 것을 선호한다고 한다.

## 린터 (Linter)

Linter라는 도구를 사용하면 내가 작성한 코드가 스타일 가이드를 준수하고 있는지를 자동으로 확인할 수 있고, 스타일 개선과 관련된 제안도 받을 수 있다. 

이렇게 자동으로 스타일을 체크받다 보면, 변수나 함수 이름에 난 오타 등이 유발하는 버그를 미리 발견할 수 있다.

가장 최근에 나온 linter 중 하나인 ESLint가 있다.

### ESLint 사용법

1. [Node.js](https://nodejs.org/)를 설치합니다.
2. npm(자바스크립트 패키지 매니저)을 사용해 다음 명령어로 ESLint를 설치합니다. `npm install -g eslint`
3. 현재 작성 중인 자바스크립트 프로젝트의 루트 폴더(프로젝트 관련 파일이 담긴 폴더)에 `.eslintrc`라는 설정 파일을 생성합니다.
4. 에디터에 ESLint 플러그인을 설치하거나 활성화합니다. 주요 에디터들은 모두 ESLint 플러그인을 지원합니다.

`.eslintrc` 파일의 예시

```jsx
{
  "extends": "eslint:recommended",
  "env": {
    "browser": true,
    "node": true,
    "es6": true
  },
  "rules": {
    "no-console": 0,
    "indent": ["warning", 2]
  }
}
```

# 주석

## 좋지 않은 주석

```jsx
// 이 코드는 (...)과 (...)을 수행합니다
// A라는 개발자가 이 기능에 대해 알고 있으며...
very;
complex;
code;
```

좋은 코드에는 설명이 담긴 주석이 많아선 안된다. 주석 없이 코드 자체만으로 코드가 무슨 일을 하는지 쉽게 이해할 수 있어야 한다.

## 좋은 주석

설명이 담긴 주석은 대체로 좋지 않다. 그렇다면 좋은 주석은 어떤 주석일까?

### 아키텍처를 설명하는 주석

고차원 수준 컴포넌트 개요, 컴포넌트 간 상호작용에 대한 설명, 상황에 따른 제어 흐름 등은 주석에 넣는게 좋다. 이런 주석은 조감도 역할을 한다.

### 함수 용례와 매개변수 정보를 담고 있는 주석

JSDoc이라는 특별한 문법을 사용하면 함수에 관한 문서를 쉽게 작성할 수 있다.

ex)

```jsx
/**
 * x를 n번 곱한 수를 반환함
 *
 * @param {number} x 거듭제곱할 숫자
 * @param {number} n 곱할 횟수, 반드시 자연수여야 함
 * @return {number} x의 n 거듭제곱을 반환함
 */
function pow(x, n) {
  ...
}
```

### 왜 이런 방법으로 문제를 해결했는지를 설명하는 주석

왜 이런 방법을 써서 문제를 해결했는지 알려주는 주석이 없으면 다음과 같은 일이 발생할 수 있다.

1. 당신(혹은 동료)은 작성된 후 시간이 꽤 흐른 코드를 열어봅니다. 그리고 그 코드에서 선택한 방식이 ‘가장 좋은 방식은 아니란 걸’ 알아냅니다.
2. "그때는 내가 멍청했구나. 하지만 지금은 더 똑똑해졌지"라고 생각하며, 이전보단 ‘더 명확하고 올바른’ 방법으로 코드를 개선합니다.
3. 코드를 개선하려는 시도까지는 좋았습니다. 하지만 리팩토링 과정에서 '더 명확’하다고 생각했던 방법을 적용하면 문제가 발생한다는 걸 알아냅니다. 이미 시도해봤던 방법이기 때문에 왜 이 방법이 먹히지 않는지 희미하게 기억이 떠오릅니다. 새로 작성한 코드를 되돌렸지만, 시간이 낭비되었습니다.

해결 방법을 담고 있는 주석은 이전에 했던 실수를 방지하는 안내판 역할을 할 수 있다.

### 미묘한 기능이 있고, 이 기능이 어디에 쓰이는지를 설명하는 주석

직감에 반하는 미묘한 동작을 수행하는 코드가 있다면 주석을 다는게 좋다.

# 닌자 코드(지양할 코드)

1. 코드 짧게 쓰기
2. 글자 하나만 사용하기 (a,b,c)
3. 약어 사용하기 (list → lst)
4. 포괄적인 명사 사용하기
5. 철자가 유사한 단어 사용하기
6. 동의어 사용하기
7. 이름 재사용하기
8. 재미로 언더스코어 사용하기 (___value)
9. 과장 형용사 사용하기
10. 외부 변수 덮어쓰기
11. 부작용이 있는 코드 작성하기
12. 함수에 다양한 기능 넣기

# 테스트 자동화와 Mocha

### 테스트는 왜 해야하는가?

코드를 수동으로 ‘재실행’ 하는 것은 불완전하다. **즉, 코드를 수동으로 ‘재실행’하면서 테스트 하는 것은 무언가를 놓치기 쉽다.**

### BDD 방법론

BDD란 Behavior Driven Development의 약자로 테스트, 문서, 예시를 한데 모아놓은 개념이다.

TDD를 기반으로 하여 개발 프로세스에 사용자의 행위와 시나리오를 중심으로 한 개발 방법론이다.

코드를 작성하기 전에 먼저 코드가 무슨일을 하는지 상상한 후 이를 자연어로 표현해야한다.

이 때 만들어진 산출물을 BDD에서는 명세서(specification)또는 스펙(spec)이라고 부른다. 명세서에는 유스 케이스에 대한 자세한 설명과 테스트가 담겨져있다.

```jsx
describe("pow", function() {

  it("주어진 숫자의 n 제곱", function() {
    assert.equal(pow(2, 3), 8);
  });

});
```

스펙은 세 가지 구성요소로 이루어져있다.

**`describe("title", function() { ... })`**

구현하고자 하는 기능에 대한 설명이 들어갑니다. 우리 예시에선 함수 `pow`가 어떤 동작을 하는지에 대한 설명이 들어갈 겁니다. `it` 블록을 한데 모아주는 역할도 합니다.

**`it("유스 케이스 설명", function() { ... })`**

`it`의 첫 번째 인수엔 특정 유스 케이스에 대한 설명이 들어갑니다. 이 설명은 *누구나 읽을 수 있고 이해할 수 있는 자연어*로 적어줍니다. 두 번째 인수엔 유스 케이스 테스트 함수가 들어갑니다.

**`assert.equal(value1, value2)`**

기능을 제대로 구현했다면 `it` 블록 내의 코드 `assert.equal(value1, value2)`이 에러 없이 실행됩니다.
함수 `assert.*`는 `pow`가 예상한 대로 동작하는지 확인해줍니다. 위 예시에선 `assert.equal`이 사용되었는데, 이 함수는 인수끼리 동등 비교했을 때 다르다고 판단되면 에러를 반환합니다. 

### 테스팅 자동화는 이런 문제를 피하게 해준다.

테스팅 자동화를 수행하고 있는 프로젝트라면 이런 문제를 걱정하지 않아도 된다. 코드에 변화가 있어도 스펙을 실행해 테스트를 진행하면 몇 초 만에 에러 발생 여부를 확인할 수 있다.

**잘 테스트 된 코드는 더 나은 아키텍처를 만든다.**

## 테스트 종류

![image](https://github.com/user-attachments/assets/fd1757fb-f120-4048-881f-d87f508f4e71)

### 단위 테스트(Unit Test)

가장 작은 규모(함수)의 기능을 테스트한다.

소프트웨어 개별 코드 단위를 테스트하여 오류를 발견하고 이를 수정하여 전체적인 소프트웨어 품질을 향상 시키는 과정

- 범위: 가장 작음
- 개별 함수, 모듈 또는 클래스 같은 작은 단위를 테스트
- 목표: 코드의 특정 부분이 올바르게 작동하는지 확인

### 통합 테스트(Integration Test)

여러가지 기능을 합쳤을 때 생기는 문제를 방지하기 위한 테스트

단위 테스트에서 검증된 개별 모듈들을 결합하여 그들이 예상대로 상호작용 하고 있는지 확인하는 테스트

- 범위: 중간
- 여러 모듈이나 컴포넌트가 함께 올바르게 작동하는지 확인
- 목표: 모듈 간의 상호작용을 점검

### E2E 테스트(End-to-End Test)

백엔드부터 시작해서 웹페이지가 원하는대로 동작하며 원하는 데이터를 잘 보여주는지 확인하는 테스트

- 범위: 가장 큼
- 애플리케이션 전체 워크플로우를 사용자 관점에서 테스트
- 목표: 시스템이 처음부터 끝까지 예상대로 동작하는지 검증 (UI, 백엔드, 데이터베이스 등 포함)

### **언제 어떤 테스트를 사용할지**

| **테스트 유형** | **사용 시점** | **목표** |
| --- | --- | --- |
| **단위 테스트** | 기능 단위의 세부 로직을 점검하고 싶을 때 | 코드의 정확성과 안정성 |
| **통합 테스트** | 모듈 간의 연결성과 데이터 흐름을 확인하고 싶을 때 | 시스템 내부의 상호작용 검증 |
| **종합 테스트** | 사용자 시나리오와 전체 시스템을 점검하고 싶을 때 | 사용자 관점에서 애플리케이션 품질 보증 |

# 폴리필

자바스크립트는 끊임없이 진화하는 언어이다. 새로운 제안(proposal)이 정기적으로 등록, 분석되고, 가치가 있다고 판단되는 제안은 https://tc39.github.io/ecma262/에 추가된다. 그리고 궁극적으로 [명세서(specification)](http://www.ecma-international.org/publications/standards/Ecma-262.htm)에 등록된다.

# [바벨](https://ko.javascript.info/polyfills#ref-155)(Babel)

명세서에 등록된 지 얼마 안 된 기능을 사용해 코드를 작성하다 보면 특정 엔진에서 우리가 작성한 코드를 지원하지 않는다는 걸 알게 되는 경우가 있다. 명세서 내 모든 기능을 모든 엔진이 구현하고 있지 않기 때문이다.

이럴 때 바벨을 사용할 수 있다.

[바벨(Babel)](https://babeljs.io/)은 [트랜스파일러(transpiler)](https://en.wikipedia.org/wiki/Source-to-source_compiler)로, 모던 자바스크립트 코드를 구 표준을 준수하는 코드로 바꿔준다.

바벨의 주요 역할은 다음과 같다.

1. 트랜스파일러 – 바벨은 코드를 재작성해주는 트랜스파일러 프로그램이다. 바벨은 개발자의 컴퓨터에서 돌아가는데, 이를 실행하면 기존 코드가 구 표준을 준수하는 코드로 변경된다. 변경된 코드는 웹사이트 형태로 사용자에게 전달된다. [웹팩(webpack)](http://webpack.github.io/)과 같은 모던 프로젝트 빌드 시스템은 코드가 수정될 때마다 자동으로 트랜스파일러를 동작시켜준다. 이런 과정이 없으면 개발이 끝난 코드를 한데 통합하는 데 어려움이 있을 수 있다.
2. 폴리필
    
    명세서엔 새로운 문법이나 기존에 없던 내장 함수에 대한 정의가 추가되곤 한다. 새로운 문법을 사용해 코드를 작성하면 트랜스파일러는 이를 구 표준을 준수하는 코드로 변경해준다. 반면, 새롭게 표준에 추가된 함수는 명세서 내 정의를 읽고 이에 맞게 직접 함수를 구현해야 사용할 수 있다. 자바스크립트는 매우 동적인 언어라서 원하기만 하면 어떤 함수라도 스크립트에 추가할 수 있다. 물론 기존 함수를 수정하는 것도 가능하다. 개발자는 스크립트에 새로운 함수를 추가하거나 수정해서 스크립트가 최신 표준을 준수할 수 있게 작업할 수 있다.
    
    이렇게 변경된 표준을 준수할 수 있게 기존 함수의 동작 방식을 수정하거나, 새롭게 구현한 함수의 스크립트를 "폴리필(polyfill)"이라 부른다. 폴리필(poly`fill`)은 말 그대로 구현이 누락된 새로운 기능을 메꿔주는(`fill in`) 역할을 한다.
    
    주목할 만한 폴리필 두 가지는 아래와 같다.
    
    - [core js](https://github.com/zloirock/core-js) – 다양한 폴리필을 제공한다. 특정 기능의 폴리필만 사용하는 것도 가능하다.
    - [polyfill.io](http://polyfill.io/) – 기능이나 사용자의 브라우저에 따라 폴리필 스크립트를 제공해주는 서비스다.
