## Hello World
### 'script'태그
Html 문서에서 javascript 코드를 사용 하고 싶을 경우 

``` html
<!-- script 태그내에 코드 삽입 -->
<script>
alert( 'Hello, world!' );
</script>

<!-- 외부 js파일 불러오기 -->
<script src="/path/to/script.js"></script>
```

위의 두 가지 방식으로 사용 할 수 있다.
<br/><br/>

```html
<script src="file.js">
  alert(1); // src 속성이 사용되었으므로 이 코드는 무시됩니다.
</script>
```

단, src속성을 이용한 외부 파일을 불러오는 script 태그 내부에는 js코드를 작성해도 무시된다.

```html
<script src="file.js"></script>
<script>
  alert(1);
</script>
```

위와 같이 따로 스크립트를 분리해주면 정삭적으로 작동된다.
<br/><br/>

또한 HTML안에 직접 스크립트 작성 할 경우는 아주 간단할 때만 작성하고 길어질 경우에는 파일을 분리하는 것이 좋다. 

스크립트를 별도의 파일로 분리하여 불러올 경우에는 브라우저가 스크립트를 다운 받아 캐시에 저장하기 때문에, 동일한 스크립트를 사용하는 페이지에서는 저장된 캐시에서 스크립트를 가져와 사용하기 때문에 트래픽이 절약되고 페이지의 속도가 빨라지는 등, 성능상의 이점이 있기 때문이다.



---
<br/>

## 코드 구조
### 세미콜론
>문(statement)은 어떤 작업을 수행하는 문법 구조(syntax structure)와 명령어(command)를 의미

코드를 작성 할 때는 세미콜론을 이용하여 문을 구분한다.

줄 바꿈이 있을 경우에 세미콜론을 생략 할 수 있는데,
```javascript
alert('Hello')
alert('World')
```
대부분의 경우, 줄 바꿈은 세미콜론을 의미하지만 **대부분의 경우** 이지 **항상**이 아니다.
<br/><br/>

```javascript
alert("에러가 발생합니다.")

[1, 2].forEach(alert)
```
위와 같은 경우가 그러한데, JS는 대괄호 앞에는 세미콜론이 있다고 가정하지 않기 때문이다.

```javascript
alert("에러가 발생합니다.")[1, 2].forEach(alert)
```
즉, 자바스크립트 엔진은 위와같이 코드를 판단하게되고, 에러가 발생하게된다.

이러한 에러는 찾기도 어렵고, 협업과정에서도 많은 트러블을 일으킬 수도 있다.

그러니 줄 바꿈으로 문을 나눴더라도 세미콜론을 넣도록 습관을 들이자.


---
<br/>

## 엄격 모드
ES5 이전에는 기존 기능을 변경하지 않으면서 새로운 기능을 추가하였지만, ES5에서는 기존 기능이 변경되어 호환성문제를 방지하기위해 엄격모드(strict mode)를 도입하였다.

`use strict` 지시자를 사용하여 엄격모드를 활성화 했을 때만 변경사항이 활성화되게 된다.
<br/><br/>

### use strict
"use strict"는 스크립트 최상단 혹은 함수 본문의 맨 앞에 위치해야 활성화된다.

대게 스크립트 전체에 적용하기위해 최상단에 작성해두지만, 함수의 맨 앞에 작성해두었을 경우에는 해당 함수만 엄격모드로 실행된다.

"use strict"의 위에는 주석만 사용할 수 있다.
또한 한 번 선언 된, 엄격모드는 취소할 수 없다.
<br/><br/>

### 꼭 사용해야 할까?
모던 자바스크립트는 '클래스'와 '모듈'이라는 구조를 제공하는데, 해당 구조에서는 엄격모드가 자동으로 적용되어 따로 use strict를 작성해 줄 필요가 없다.

하지만 그 외의 경우에서는 사용하는걸 권유한다.

---
<br/>

## 변수와 상수
변수 선언에는 var와 let을 이용 할 수 있지만,
var는 오래된 방식으로 let을 사용한다.

상수 선언에는 const를 사용한다.
<br/><br/>

var 는 재선언&재할당이 가능하며, 선언 된 함수 내부 어디서든 참조 가능한 함수 스코프 범위를 가지며 호이스팅 될 때 변수 선언 이전에 호출할 경우 undefined를 출력한다.
<br/><br/>


let 은 재선언은 불가능하며, 재할당은 가능하다.

{}블록 내부에서만 참조되는 블록스코프 단위를 가지며, 호이스팅 발생 시, TDZ(Temporal Dead Zone)이 존재하기 때문에 변수 선언 이전에 호출 할 경우 ReferenceError를 출력한다.
<br/><br/>

const는 재선언, 재할당 모두 불가능하며 선언 당시에 값을 꼭 같이 할당해주어야한다.

또한 let과 같이 블록스코프단위를 가지며, 호이스팅 발생 시 TDZ가 존재한다.
<br/><br/>

### 변수 명명 규칙
1. 변수명에는 오직 문자와 숫자, 그리고 기호 $와 _만 들어갈 수 있다.
2. 첫 글자는 숫자가 될 수 없다.
3. 대소문자는 구별된다.
4. 간결하고 명확한 변수명을 지어야한다.

---
<br/>

## 기본 연산자와 수학
### 나머지 연산자 %
```javascript
alert( 5 % 2 ); // 5를 2로 나눈 후의 나머지인 1을 출력
alert( 8 % 3 ); // 8을 3으로 나눈 후의 나머지인 2를 출력
```
나머지 연산자를 사용한 표현식 a%b는 a를 b로 나눈 후 그 나머지를 정수로 반환한다.
<br/><br/>

### 거듭제곱 연산자 \**
```javascript
alert( 2 ** 2 ); // 4  (2 * 2)
alert( 2 ** 3 ); // 8  (2 * 2 * 2)
alert( 2 ** 4 ); // 16 (2 * 2 * 2 * 2)
```
거듭제곱 연산자를 사용한 표현식 a**b는 a를 b번 곱한 값을 반환한다.
<br/><br/>

```javascript
alert( 4 ** (1/2) ); // 2 (1/2 거듭제곱은 제곱근)
alert( 8 ** (1/3) ); // 2 (1/3 거듭제곱은 세제곱근)
```

거듭제곱 연산자는 정수가 아닌 숫자에서도 동작한다.
1/2을 사용하면 제곱근을 구할 수 있다.
<br/><br/>


### 이항 연산자 + 와 문자열 연결
이항 연산자에서 +는 문자열 연결과 변환이라는 특별한 기능을 제공한다. 

```javascript
alert( '1' + 2 ); // "12"
alert( 2 + '1' ); // "21"
```
이처럼 피연산자 . 중하나가 문자열이면 다른 하나도 문자열로 변환되어 연결된다.
<br/><br/>

```javascript
alert(2 + 2 + '1' ); // '221'이 아니라 '41'이 출력됩니다.
```
단, 연산은 왼쪽에서 오른쪽으로 순차적으로 진행되기 때문에 두개의 피연산자가 모두 숫자인 `2 + 2`는 숫자로서 더해져 4가 되고 이후 `+ '1'`에서는 `숫자 + 문자`로 계산되어 41이라는 값을 반환한다.
<br/><br/>

처음 서술했듯 문자열 연결과 변환은 이항연산자에서의 + 의 특별한 기능이다.
```javascript
alert( 6 - '2' ); // 4, '2'를 숫자로 바꾼 후 연산이 진행됩니다.
alert( '6' / '2' ); // 3, 두 피연산자가 숫자로 바뀐 후 연산이 진행됩니다.
```
\- 와  / 연산자는 위처럼 오직 숫자형의 피연산자만 다루고, 피연산자가 숫자형이 아닌 경우에는 숫자형으로 바꾸어 계산한다.
<br/><br/>

### 단항 연산자 + 와 숫자형 변환
단항 연산자 + 는 숫자가 아닌 경우엔 숫자형으로의 변환이 일어난다.

```javascript
// 숫자형이 아닌 피연산자는 숫자형으로 변화합니다.
alert( +true ); // 1
alert( +"" );   // 0
```

truthy한 값은 1을 반환하고 falsy한 값은 0을 반환한다.
<br/><br/>

또한 단항연산자 +는 `Number()`와 동일한 일을 할 수 있게 해준다.

```javascript
let apples = "2";
let oranges = "3";

alert( apples + oranges ); // 23, 이항 덧셈 연산자는 문자열을 연결합니다.
```
위 처럼 이항 연산자에서는 단순히 문자열을 연결하지만

```javascript
// 이항 덧셈 연산자가 적용되기 전에, 두 피연산자는 숫자형으로 변화합니다.
alert( +apples + +oranges ); // 5

// `Number(...)`를 사용해서 같은 동작을 하는 코드를 작성할 수 있지만, 더 길다.
// alert( Number(apples) + Number(oranges) ); // 5
```
`+apples`, `+oranges`와 같이 단항연산자로서 +를 사용하게 되면 `Number()`와 같은 역할을 하여 2+3=5 라는 계산식으로 동작하게 된다.
<br/><br/>

### 연산자 우선순위
하나의 표현식에 둘 이상의 연산자가 있는 경우, 실행 순서는 연산자의 우선순위에 의해 결졍된다.

우선순위 숫자가 클수록 먼저 실행되며, 순위가 같을 경우에는 왼쪽부터 오른쪽으로 연산이 수행된다.

<a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/Operator_precedence" target="_blank">우선순위 테이블</a>을 통해 우선순위를 확인 할 수 있으며, 순서를 기억 할 필요는 없지만, 동일한 기호의 단항연산자는 이항 연산자보다 우선순위가 높다는 것은 알아 둘 필요가 있다.
<br/><br/>

### 복합 할당 연산자
```javascript
let n = 2;
n = n + 5;
n = n * 2;
```
변수에 연산자를 적용하고, 그 결과를 같은 변수에 저장해야 하는 경우,

```javascript
let n = 2;
n += 5; // n은 7이 됩니다(n = n + 5와 동일).
n *= 2; // n은 14가 됩니다(n = n * 2와 동일).
```
`+=`, `*=`과 같은 복합 할당 연산자를 이용하여 짧은 문법으로 연산을 수행 할 수 있다.
<br/><br/>

### 증가(++)/감소(--) 연산자
증가 연산자는 변수를 1 증가시키고,
감소 연산자는 변수를 1 감소시킨다.

증가/감소 연산자는 변수에만 사용 가능하며, 변수의 앞이나 뒤에 올 수 있다.

- counter++와 같이 피연산자 뒤에 올 때는, '후위형(postfix form)'이라고 부릅니다.
- ++counter와 같이 피연산자 앞에 올 때는, '전위형(prefix form)'이라고 부릅니다.

전위형, 후위형 모두 1을 증감 시켜준다는 동일한 동작을 하지만, 반환 값을 사용 할 때 차이점이 드러난다.

```javascript
let counter = 0;
counter++; // 1
++counter; // 2
alert( counter ); // 2, 위 두 라인은 동일한 연산을 수행합니다.
```
반환 값을 사용하지 않을 때에는, 차이가 없지만

```javascript
let counter = 1;
let a = ++counter;

alert(a); // 2
```
반환 값이 있을 경우, 전위형은 값을 증가시킨 새로운 값을 반환하고,

```javascript
let counter = 1;
let a = counter++; 

alert(a); // 1
```
후위형은 counter를 증가시키긴 하지만, 증가 전의 **기존값**을 반환한다.

---
<br/>

## 비교 연산자
비교 연산자는 불린형을 반환한다.

### 문자열 비교
자바스크립트는 '사전'순으로 문자열을 비교한다.
'사전편집'순이라고 불리기도 하는 이 기준은 사전 뒤쪽의 문자열을 사전 앞쪾의 문자열보다 크다고 판단한다.
```javascript
alert( 'Z' > 'A' ); // true
```

>**정확히는 사전 순이 아니라 유니코드 순이다**<br/><br/>자바스크립트는 대/소문자를 따진다. 대문자 `A`와 소문자 `a`를 비교 했을 때, 자바스크립트 내부에 사용되는 인코딩 표인 유니코드에서는 소문자가 대문자보다 더 큰 인덱스를 갖기 때문에 소문자 `a`가 더 크다.

<br/><br/>

### 다른 형을 가진 값 간의 비교
비교하려는 값의 자료형이 다르면 자바스크립트는 값들을 숫자형으로 바꾼다.

```javascript
alert( '2' > 1 ); // true, 문자열 '2'가 숫자 2로 변환된 후 비교가 진행됩니다.
alert( '01' == 1 ); // true, 문자열 '01'이 숫자 1로 변환된 후 비교가 진행됩니다.
```
<br/><br/>

### 일치 연산자(===)
일치 연산자와 불일치 연산자를 사용하면 형 변환없이 값을 비교하여 비교 결과가 명확하기 때문에 에러가 발생할 확률이 줄어든다.

```javascript
alert( 0 == false ); // true
```
false를 0으로 변환하여 true를 반환하는 동등 연산자와 달리

```javascript
alert( 0 === false ); // false
```
일치 연산자는 형을 변환하지 않아 false를 반환한다.
<br/><br/>

### null / undefined 비교하기

동등 연산자 `==`는 피연산자가 `undefined`나 `null`일 때 형 변환을 하지 않는다.

```javascript
alert( null == undefined ); // true
```
하지만 `null`과 `undefined`를 비교 할 때는 특별한 규칙이 적용되어 `true`를 반환한다.

동등 연산자가 아닌, 산술 연산자난 기타 비교연산자를 사용할 경우에는 숫자형으로 변환되어
`null`은 `0`,
`undefined`는 `NaN`으로 변환된다.

변수가 `undefined`나 `null`이 될 가능성이 있다고 판단되면, 이를 따로 처리하는 코드를 추가하는 습관을 들이는 것이 좋다.

---
<br/>

## if와 '?'를 사용한 조건 처리
### if문
`if(...)`문은 괄호 안의 표현 식을 평가하고 그 결과를 불린값으로 변환하여 결과가 `true`일 경우 코드 블록을 실행한다.
<br/><br/>

### 조건부 연산자 '?'
'물음표 연산자'라고도 불리는 '조건부 연산자'는 피 연산자가 세 개이기 때문에 '삼항 연산자' 라고도 불린다.
자바 스크립트에서 피연산자를 3개나 받는 연산자는 조건부 연산자가 유일하다.

```javascript
let result = condition ? value1 : value2;
```
위와 같은 문법으로 사용되며, `condition`이 truthy한 값이라면 `value1`을, 그렇지 않으면 `value2`를 반환한다.
<br/><br/>

### 부적절한 '?'
```javascript
let company = prompt('자바스크립트는 어떤 회사가 만들었을까요?', '');

(company == 'Netscape') ?
   alert('정답입니다!') : alert('오답입니다!');
```
위의 예시는 결과를 변수에 할당하지 않고, 결과에 따라 실행되는 표현식이 달라지도록 하였다.

**이런 식으로 조건부 연산자를 사용하는 것은 좋지 않다**

조건부 연산자는 조건에 따라 반환 값을 달리 하려는 목적으로 만들어졌다. 반환 값이 아닌 여러 분기를 만들어 처리 할 때는 `if`문을 사용하자.
```javascript
let company = prompt('자바스크립트는 어떤 회사가 만들었을까요?', '');

if (company == 'Netscape') {
  alert('정답입니다!');
} else {
  alert('오답입니다!');
}
```
---
<br/>

## 논리 연산자
### || (OR)
```javascript
let result = a || b;
```
OR 연산자는 인수 중 하나라도 `true`이면 `true`를 반환한다.

ex)
```javascript
let hour = 12;
let isWeekend = true;

if (hour < 10 || hour > 18 || isWeekend) {
  alert( '영업시간이 아닙니다.' ); // 주말이기 때문임
}
```
<br/><br/>

### 첫 번째 truthy를 찾는 OR 연산자 '||'
자바스크립트에서만 제공하는 논리연산자 OR의 추가 기능이 있다.
추가 기능은 아래와 같은 알고리즘으로 동작한다.

```javascript
result = value1 || value2 || value3;
```

- 가장 왼쪽 피연산자부터 시작해 오른쪽으로 나아가며 피연산자를 평가합니다.
- 각 피연산자를 불린형으로 변환합니다. 변환 후 그 값이 true이면 연산을 멈추고 해당 피연산자의 변환 전 원래 값을 반환합니다.
- 피연산자 모두를 평가한 경우(모든 피연산자가 false로 평가되는 경우)엔 마지막 피연산자를 반환합니다.

핵심은 반환값이 형 변환을 하지 않은 원래 값이라는 것이다.

추가기능을 이용하면 여러 용도로 OR 연산자를 활용할 수 있다.

1. 변수 또는 표현식으로 구성된 목록에서 첫 번째 truthy 얻기
```javascript
let firstName = "";
let lastName = "";
let nickName = "바이올렛";

alert( firstName || lastName || nickName || "익명"); // 바이올렛
```
실제 값이 있는 변수를 찾고, 그 값을 보여주도록 할 수 있다.
만약 모든 변수에 값이 없었다면 '익명'이 출력되었을 것이다.

2. 단락 평가
```javascript
false || alert("printed");
```
OR 연산자는 왼쪽부터 시작해서 오른쪽으로 평가를 진행하는데, truthy를 만나면 나머지 값은 건드리지 않고 평가를 멈춘다. 이런 프로세스를 '단락 평가'라고 한다.

단락 평가는 두 번째 피연산자가 변수 할당과 같은 부수적인 효과를 가지는 표현식 일 때 명확히 볼 수 있으며, 연산자 왼쪽 조건이 falsy일 때만 명령어를 실행하고자 할 때 자주 쓰인다.
<br/><br/>

### && (AND)
```javascript
result = a && b;
```
AND 연산자는 두 피연산자가 모두 참일 때 `true`를 반환한다.
ex)
```javascript
if (1 && 0) { // 피연산자가 숫자형이지만 논리형으로 바뀌어 true && false가 됩니다.
  alert( "if 문 안에 falsy가 들어가 있으므로 alert창은 실행되지 않습니다." );
}
```
<br/><br/>

### 첫 번째 falsy를 찾는 AND 연산자 '&&'
```javascript
result = value1 && value2 && value3;
```
- 가장 왼쪽 피연산자부터 시작해 오른쪽으로 나아가며 피연산자를 평가합니다.
- 각 피연산자는 불린형으로 변환됩니다. 변환 후 값이 false이면 평가를 멈추고 해당 피연산자의 변환 전 원래 값을 반환합니다.
- 피연산자 모두가 평가되는 경우(모든 피연산자가 true로 평가되는 경우)엔 마지막 피연산자가 반환됩니다.

AND 연산자는 OR 연산자의 알고리즘과 유사하나 AND연산자는 첫 번째 truthy가 아닌 falsy를 반환하는 차이가 있다.
<br/><br/>

**`&&`의 우선순위가 `||`보다 높다**  
따라서 `a && b || c && d`는 `(a && b) || (c && d)`와 동일하게 동작한다.


**\* if를 ||나 &&로 대체하지 말자**
```javascript
let x = 1;

(x > 0) && alert( '0보다 큽니다!' );
```
if 대신 &&을 사용한 코드가 더 짧긴 하지만

```javascript
if (x > 0) alert( '0보다 큽니다!' );
```
if문을 사용하면 무엇을 구현하고자 했는지 더 명백히 드러나고, 가독성도 좋아진다.

if 조건문이 필요하면 if를 사용하고 AND 연산자는 연산자 목적에 맞게 사용하자.
<br/><br/>

### !(NOT)
```javascript
result = !value;
```
- 피연산자(value)를 불린형(true / false)으로 변환합니다.
- 1에서 변환된 값의 역을 반환합니다.

NOT 연산자를 두 개 연달아 사용하면 Boolean과 같은 결과를 도출한다.

```javascript
alert( !!"non-empty string" ); // true
alert( !!null ); // false
```

```javascript
alert( Boolean("non-empty string") ); // true
alert( Boolean(null) ); // false
```

---
<br/>

## nullish 병합 연산자 '??'
```javascript
let firstName = null;
let lastName = null;
let nickName = "바이올렛";

// null이나 undefined가 아닌 첫 번째 피연산자
alert(firstName ?? lastName ?? nickName ?? "익명의 사용자"); // 바이올렛
```

nullish 병합 연산자 ?? 는 짧은 문법으로 여러 피연산자 중 값이 '확정 되어있는' 변수를 찾을 수 있다.
<br/><br/>

### '??'와 '||'의 차이 
`||`는 첫 번째 truthy값을 반환하고, `??`는 첫 번째 정의된 값을 반환한다는 주요한 차이점이 있다.

`null`과 `undefined`, 숫자 `0`을 구분 지어 다뤄야 할 때 매우 중요한 역할을 한다.

```javascript
let height = 0;

alert(height || 100); // 100
alert(height ?? 100); // 0
```

`||`는 0을 falsy한 값으로 취급했기 때문에 100을 출력하지만,
`??` 는 `null`이나 `undefined`가 아닌 0이라는 값이 할당되어있기 때문에 0을 출력한다.

0이 할당될 수 있는 변수를 사용해 기능을 개발 할 땐 `||` 보다는 `??` 가 적합하다.
<br/><br/>

### 연산자 우선순위
`??` 연산자는 안정성 관련 이슈 때문에 `&&`나 `||`와 함께 사용하지 못한다.
```javascript
let x = 1 && 2 ?? 3; // SyntaxError: Unexpected token '??'
```
`||`를 `??`로 바꾸기 시작하면서 만드는 실수를 방지하고자 추가된 제약이다.

위 제약을 피하기 위해서는 괄호를 사용하면 된다.
또한, `??`는 연산자 우선순위가 낮은 편이라 `??`를 사용해 값을 하나 선택할 땐 괄호를 추가하는게 좋다.

```javascript
let x = (1 && 2) ?? 3; // 제대로 동작합니다.

alert(x); // 2
```
---
<br/>

## while과 for 반복문
```javascript
while (condition) {
  // 코드
  // '반복문 본문(body)'이라 불림
}
```
while 반복문은 condition이 truthy이면 body의 코드가 실행된다.

ex)
```javascript
let i = 0;
while (i < 3) { // 0, 1, 2가 출력됩니다.
  alert( i );
  i++;
}
```
<br/><br/>

### 'do...while' 반복문
```javascript
do {
  // 반복문 본문
} while (condition);
```
본문이 먼저 실행되고, 조건을 확인 한 후 조건이 truthy인 동안 본문이 계속 실행된다.

`do...while` 문법은 처음 조건이 truthy인지 아닌지에 상관없이, 본문을 최소한 한 번이라도 실해앟고 싶을 때만 사용한다.
<br/><br/>

### 'for'반복문
