## Hello World
### 'script'태그
Html 문서에서 javascript 코드를 사용 하고 싶을 경우 

``` html
<!-- script 태그내에 코드 삽입 -->
<script>
alert( 'Hello, world!' );
</script>

<!-- 외부 js파일 불러오기 -->
<script src="/path/to/script.js"></script>
```

위의 두 가지 방식으로 사용 할 수 있다.
<br/><br/>

```html
<script src="file.js">
  alert(1); // src 속성이 사용되었으므로 이 코드는 무시됩니다.
</script>
```

단, src속성을 이용한 외부 파일을 불러오는 script 태그 내부에는 js코드를 작성해도 무시된다.

```html
<script src="file.js"></script>
<script>
  alert(1);
</script>
```

위와 같이 따로 스크립트를 분리해주면 정삭적으로 작동된다.
<br/><br/>

또한 HTML안에 직접 스크립트 작성 할 경우는 아주 간단할 때만 작성하고 길어질 경우에는 파일을 분리하는 것이 좋다. 

스크립트를 별도의 파일로 분리하여 불러올 경우에는 브라우저가 스크립트를 다운 받아 캐시에 저장하기 때문에, 동일한 스크립트를 사용하는 페이지에서는 저장된 캐시에서 스크립트를 가져와 사용하기 때문에 트래픽이 절약되고 페이지의 속도가 빨라지는 등, 성능상의 이점이 있기 때문이다.



---
<br/>

## 코드 구조
### 세미콜론
>문(statement)은 어떤 작업을 수행하는 문법 구조(syntax structure)와 명령어(command)를 의미

코드를 작성 할 때는 세미콜론을 이용하여 문을 구분한다.

줄 바꿈이 있을 경우에 세미콜론을 생략 할 수 있는데,
```javascript
alert('Hello')
alert('World')
```
대부분의 경우, 줄 바꿈은 세미콜론을 의미하지만 **대부분의 경우** 이지 **항상**이 아니다.
<br/><br/>

```javascript
alert("에러가 발생합니다.")

[1, 2].forEach(alert)
```
위와 같은 경우가 그러한데, JS는 대괄호 앞에는 세미콜론이 있다고 가정하지 않기 때문이다.

```javascript
alert("에러가 발생합니다.")[1, 2].forEach(alert)
```
즉, 자바스크립트 엔진은 위와같이 코드를 판단하게되고, 에러가 발생하게된다.

이러한 에러는 찾기도 어렵고, 협업과정에서도 많은 트러블을 일으킬 수도 있다.

그러니 줄 바꿈으로 문을 나눴더라도 세미콜론을 넣도록 습관을 들이자.


---
<br/>

## 엄격 모드
ES5 이전에는 기존 기능을 변경하지 않으면서 새로운 기능을 추가하였지만, ES5에서는 기존 기능이 변경되어 호환성문제를 방지하기위해 엄격모드(strict mode)를 도입하였다.

`use strict` 지시자를 사용하여 엄격모드를 활성화 했을 때만 변경사항이 활성화되게 된다.
<br/><br/>

### use strict
"use strict"는 스크립트 최상단 혹은 함수 본문의 맨 앞에 위치해야 활성화된다.

대게 스크립트 전체에 적용하기위해 최상단에 작성해두지만, 함수의 맨 앞에 작성해두었을 경우에는 해당 함수만 엄격모드로 실행된다.

"use strict"의 위에는 주석만 사용할 수 있다.
또한 한 번 선언 된, 엄격모드는 취소할 수 없다.
<br/><br/>

### 꼭 사용해야 할까?
모던 자바스크립트는 '클래스'와 '모듈'이라는 구조를 제공하는데, 해당 구조에서는 엄격모드가 자동으로 적용되어 따로 use strict를 작성해 줄 필요가 없다.

하지만 그 외의 경우에서는 사용하는걸 권유한다.

---
<br/>

## 변수와 상수
변수 선언에는 var와 let을 이용 할 수 있지만,
var는 오래된 방식으로 let을 사용한다.

상수 선언에는 const를 사용한다.
<br/><br/>

var 는 재선언&재할당이 가능하며, 선언 된 함수 내부 어디서든 참조 가능한 함수 스코프 범위를 가지며 호이스팅 될 때 변수 선언 이전에 호출할 경우 undefined를 출력한다.
<br/><br/>


let 은 재선언은 불가능하며, 재할당은 가능하다.

{}블록 내부에서만 참조되는 블록스코프 단위를 가지며, 호이스팅 발생 시, TDZ(Temporal Dead Zone)이 존재하기 때문에 변수 선언 이전에 호출 할 경우 ReferenceError를 출력한다.
<br/><br/>

const는 재선언, 재할당 모두 불가능하며 선언 당시에 값을 꼭 같이 할당해주어야한다.

또한 let과 같이 블록스코프단위를 가지며, 호이스팅 발생 시 TDZ가 존재한다.
<br/><br/>

### 변수 명명 규칙
1. 변수명에는 오직 문자와 숫자, 그리고 기호 $와 _만 들어갈 수 있다.
2. 첫 글자는 숫자가 될 수 없다.
3. 대소문자는 구별된다.
4. 간결하고 명확한 변수명을 지어야한다.

---
<br/>

## 기본 연산자와 수학
### 나머지 연산자 %
```javascript
alert( 5 % 2 ); // 5를 2로 나눈 후의 나머지인 1을 출력
alert( 8 % 3 ); // 8을 3으로 나눈 후의 나머지인 2를 출력
```
나머지 연산자를 사용한 표현식 a%b는 a를 b로 나눈 후 그 나머지를 정수로 반환한다.
<br/><br/>

### 거듭제곱 연산자 \**
```javascript
alert( 2 ** 2 ); // 4  (2 * 2)
alert( 2 ** 3 ); // 8  (2 * 2 * 2)
alert( 2 ** 4 ); // 16 (2 * 2 * 2 * 2)
```
거듭제곱 연산자를 사용한 표현식 a**b는 a를 b번 곱한 값을 반환한다.
<br/><br/>

```javascript
alert( 4 ** (1/2) ); // 2 (1/2 거듭제곱은 제곱근)
alert( 8 ** (1/3) ); // 2 (1/3 거듭제곱은 세제곱근)
```

거듭제곱 연산자는 정수가 아닌 숫자에서도 동작한다.
1/2을 사용하면 제곱근을 구할 수 있다.
<br/><br/>


### 이항 연산자 + 와 문자열 연결
이항 연산자에서 +는 문자열 연결과 변환이라는 특별한 기능을 제공한다. 

```javascript
alert( '1' + 2 ); // "12"
alert( 2 + '1' ); // "21"
```
이처럼 피연산자 . 중하나가 문자열이면 다른 하나도 문자열로 변환되어 연결된다.
<br/><br/>

```javascript
alert(2 + 2 + '1' ); // '221'이 아니라 '41'이 출력됩니다.
```
단, 연산은 왼쪽에서 오른쪽으로 순차적으로 진행되기 때문에 두개의 피연산자가 모두 숫자인 `2 + 2`는 숫자로서 더해져 4가 되고 이후 `+ '1'`에서는 `숫자 + 문자`로 계산되어 41이라는 값을 반환한다.
<br/><br/>

처음 서술했듯 문자열 연결과 변환은 이항연산자에서의 + 의 특별한 기능이다.
```javascript
alert( 6 - '2' ); // 4, '2'를 숫자로 바꾼 후 연산이 진행됩니다.
alert( '6' / '2' ); // 3, 두 피연산자가 숫자로 바뀐 후 연산이 진행됩니다.
```
\- 와  / 연산자는 위처럼 오직 숫자형의 피연산자만 다루고, 피연산자가 숫자형이 아닌 경우에는 숫자형으로 바꾸어 계산한다.
<br/><br/>

### 단항 연산자 + 와 숫자형 변환
단항 연산자 + 는 숫자가 아닌 경우엔 숫자형으로의 변환이 일어난다.

```javascript
// 숫자형이 아닌 피연산자는 숫자형으로 변화합니다.
alert( +true ); // 1
alert( +"" );   // 0
```

truthy한 값은 1을 반환하고 falsy한 값은 0을 반환한다.
<br/><br/>

또한 단항연산자 +는 `Number()`와 동일한 일을 할 수 있게 해준다.

```javascript
let apples = "2";
let oranges = "3";

alert( apples + oranges ); // 23, 이항 덧셈 연산자는 문자열을 연결합니다.
```
위 처럼 이항 연산자에서는 단순히 문자열을 연결하지만

```javascript
// 이항 덧셈 연산자가 적용되기 전에, 두 피연산자는 숫자형으로 변화합니다.
alert( +apples + +oranges ); // 5

// `Number(...)`를 사용해서 같은 동작을 하는 코드를 작성할 수 있지만, 더 길다.
// alert( Number(apples) + Number(oranges) ); // 5
```
`+apples`, `+oranges`와 같이 단항연산자로서 +를 사용하게 되면 `Number()`와 같은 역할을 하여 2+3=5 라는 계산식으로 동작하게 된다.
<br/><br/>

### 연산자 우선순위
하나의 표현식에 둘 이상의 연산자가 있는 경우, 실행 순서는 연산자의 우선순위에 의해 결졍된다.

우선순위 숫자가 클수록 먼저 실행되며, 순위가 같을 경우에는 왼쪽부터 오른쪽으로 연산이 수행된다.

<a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/Operator_precedence" target="_blank">우선순위 테이블</a>을 통해 우선순위를 확인 할 수 있으며, 순서를 기억 할 필요는 없지만, 동일한 기호의 단항연산자는 이항 연산자보다 우선순위가 높다는 것은 알아 둘 필요가 있다.
<br/><br/>

### 복합 할당 연산자
```javascript
let n = 2;
n = n + 5;
n = n * 2;
```
변수에 연산자를 적용하고, 그 결과를 같은 변수에 저장해야 하는 경우,

```javascript
let n = 2;
n += 5; // n은 7이 됩니다(n = n + 5와 동일).
n *= 2; // n은 14가 됩니다(n = n * 2와 동일).
```
`+=`, `*=`과 같은 복합 할당 연산자를 이용하여 짧은 문법으로 연산을 수행 할 수 있다.
<br/><br/>

### 증가(++)/감소(--) 연산자
증가 연산자는 변수를 1 증가시키고,
감소 연산자는 변수를 1 감소시킨다.

증가/감소 연산자는 변수에만 사용 가능하며, 변수의 앞이나 뒤에 올 수 있다.

- counter++와 같이 피연산자 뒤에 올 때는, '후위형(postfix form)'이라고 부릅니다.
- ++counter와 같이 피연산자 앞에 올 때는, '전위형(prefix form)'이라고 부릅니다.

전위형, 후위형 모두 1을 증감 시켜준다는 동일한 동작을 하지만, 반환 값을 사용 할 때 차이점이 드러난다.

```javascript
let counter = 0;
counter++; // 1
++counter; // 2
alert( counter ); // 2, 위 두 라인은 동일한 연산을 수행합니다.
```
반환 값을 사용하지 않을 때에는, 차이가 없지만

```javascript
let counter = 1;
let a = ++counter;

alert(a); // 2
```
반환 값이 있을 경우, 전위형은 값을 증가시킨 새로운 값을 반환하고,

```javascript
let counter = 1;
let a = counter++; 

alert(a); // 1
```
후위형은 counter를 증가시키긴 하지만, 증가 전의 **기존값**을 반환한다.

---
<br/>

## 비교 연산자
비교 연산자는 불린형을 반환한다.

### 문자열 비교
자바스크립트는 '사전'순으로 문자열을 비교한다.
'사전편집'순이라고 불리기도 하는 이 기준은 사전 뒤쪽의 문자열을 사전 앞쪾의 문자열보다 크다고 판단한다.
```javascript
alert( 'Z' > 'A' ); // true
```

>**정확히는 사전 순이 아니라 유니코드 순이다**<br/><br/>자바스크립트는 대/소문자를 따진다. 대문자 `A`와 소문자 `a`를 비교 했을 때, 자바스크립트 내부에 사용되는 인코딩 표인 유니코드에서는 소문자가 대문자보다 더 큰 인덱스를 갖기 때문에 소문자 `a`가 더 크다.

<br/><br/>

### 다른 형을 가진 값 간의 비교
비교하려는 값의 자료형이 다르면 자바스크립트는 값들을 숫자형으로 바꾼다.

```javascript
alert( '2' > 1 ); // true, 문자열 '2'가 숫자 2로 변환된 후 비교가 진행됩니다.
alert( '01' == 1 ); // true, 문자열 '01'이 숫자 1로 변환된 후 비교가 진행됩니다.
```
<br/><br/>

### 일치 연산자(===)
일치 연산자와 불일치 연산자를 사용하면 형 변환없이 값을 비교하여 비교 결과가 명확하기 때문에 에러가 발생할 확률이 줄어든다.

```javascript
alert( 0 == false ); // true
```
false를 0으로 변환하여 true를 반환하는 동등 연산자와 달리

```javascript
alert( 0 === false ); // false
```
일치 연산자는 형을 변환하지 않아 false를 반환한다.
<br/><br/>

### null / undefined 비교하기

동등 연산자 `==`는 피연산자가 `undefined`나 `null`일 때 형 변환을 하지 않는다.

```javascript
alert( null == undefined ); // true
```
하지만 `null`과 `undefined`를 비교 할 때는 특별한 규칙이 적용되어 `true`를 반환한다.

동등 연산자가 아닌, 산술 연산자난 기타 비교연산자를 사용할 경우에는 숫자형으로 변환되어
`null`은 `0`,
`undefined`는 `NaN`으로 변환된다.

변수가 `undefined`나 `null`이 될 가능성이 있다고 판단되면, 이를 따로 처리하는 코드를 추가하는 습관을 들이는 것이 좋다.

---
<br/>

## if와 '?'를 사용한 조건 처리
### if문
`if(...)`문은 괄호 안의 표현 식을 평가하고 그 결과를 불린값으로 변환하여 결과가 `true`일 경우 코드 블록을 실행한다.
<br/><br/>

### 조건부 연산자 '?'
'물음표 연산자'라고도 불리는 '조건부 연산자'는 피 연산자가 세 개이기 때문에 '삼항 연산자' 라고도 불린다.
자바 스크립트에서 피연산자를 3개나 받는 연산자는 조건부 연산자가 유일하다.

```javascript
let result = condition ? value1 : value2;
```
위와 같은 문법으로 사용되며, `condition`이 truthy한 값이라면 `value1`을, 그렇지 않으면 `value2`를 반환한다.
<br/><br/>

### 부적절한 '?'
```javascript
let company = prompt('자바스크립트는 어떤 회사가 만들었을까요?', '');

(company == 'Netscape') ?
   alert('정답입니다!') : alert('오답입니다!');
```
위의 예시는 결과를 변수에 할당하지 않고, 결과에 따라 실행되는 표현식이 달라지도록 하였다.

**이런 식으로 조건부 연산자를 사용하는 것은 좋지 않다**

조건부 연산자는 조건에 따라 반환 값을 달리 하려는 목적으로 만들어졌다. 반환 값이 아닌 여러 분기를 만들어 처리 할 때는 `if`문을 사용하자.
```javascript
let company = prompt('자바스크립트는 어떤 회사가 만들었을까요?', '');

if (company == 'Netscape') {
  alert('정답입니다!');
} else {
  alert('오답입니다!');
}
```
---
<br/>

## 논리 연산자
### || (OR)
```javascript
let result = a || b;
```
OR 연산자는 인수 중 하나라도 `ture`이면 `true`를 반환한다.

