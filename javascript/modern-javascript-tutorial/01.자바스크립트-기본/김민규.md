# 자바스크립트 기본

## 모던 마크업

`<script>` 태그에서는 몇가지 속성(attribute)가 있고 요즘은 잘 사용하지 않는데, 오래된 코드에서 종종 이 속성을 발견할 수 있다. 이전(HTML4)에서는 `type`을 명시하는게 필수였지만 지금은 안써도 된다. 모던 HTML 표준에선 이 속성의 의미가 변경되었고 `type`의 경우 모듈에 사용할 수 있다. 모듈 같은 경우는 심화 과정때 배우므로 정리해서 해당 글과 연결하도록 하겠다.

```javascript
<script type="module"></script>
```

type과 마찬가지로 이제 사용하지 않는 속성이 있는데, `<script language=..>` 속성이 있다. 현재는 자바스크립트가 기본 언어이므로 속성의 의미가 퇴색해서 더는 사용할 필요가 없어짐

- `<script>` 태그에 여러가지 속성이 있는데, 요즘 잘 사용안하고 오래된 코드에서 볼 수 있음
- 혹시라도 보게 되면 당황하지말고 아~ 오래된 코드구나 하고 넘어가셈
- type은 모듈에 사용할 수 있으므로 심화 과정때 정리하려함

## 외부 스크립트

이번에 문서를 통해 알게 된 것은 스크립트를 별도의 파일에 작성하면 브라우저가 스크립트를 다운받아 `캐시(cache)`에 저장한다는 것이었다. 이전에는 코드가 길어질 때와 구조화하는 용도로 외부 스크립트로 분리한다 생각했는데, 이 부분은 처음 안 사실이었다.

- 여러 페이지에서 동일한 스크립트를 사용할 때 브라우저는 <u>페이지가 변경될 때 마다 스크립트를 새로 다운받지 않고 캐시</u>로부터 스크립트를 가져옴
- 스크립트 파일을 한 번만 다운받으면 되기에 `트래픽이 절약`되고 웹 페이지의 실제 `속도가 빨라짐`

### defer와 async 차이

스크립트 태그에 `defer`와 `async` 속성도 본 적이 있다. 이 부분은 문서에 없는 내용이지만, 글을 작성하는 김에 따로 찾아보고 정리해봤다.

#### defer

- HTML 파싱이 끝난 후 스크립트를 실행
- 스크립트가 병렬로 로드되며, 실행 순서가 HTML에 선언된 순서를 따름
- 파일이 순소대로 실행되어야 할 때 사용함

```javascript
// 작성 예시
<script src="defer.js" defer></script>
```

#### async

- 스크립트를 병렬로 로드하고, 로드가 완료되면 HTML 파싱을 중단하고 즉시 실행함
- 실행 순서가 보장되지 않음
- 실행 순서가 중요하지 않은 독립적인 스크립트임 (광고같은 곳에 사용됨)

```javascript
// 작성 예시
<script src="async.js" async></script>
```

### 스크립트 위치

- 스크립트는 HTML 문서에서 위치하는 곳에 따라 브라우저 동작이 달라지므로 이해하고 사용해야 함.
- 모던 프로젝트에서는 일반적으로 `defer`를 사용해 `<head>`에 배치하는 방식을 선호한다고함.

#### `<head>` 내부

- HTML 파싱 전에 스크립트를 로드하고 실행함 (DOM이 준비되지 않음)
- `defer` 또는 `async` 속성과 함께 사용함
- DOM이 준비되지 않으니 DOM을 조작하는 경우 에러남

#### `</body>` 바로 앞

- HTML 파싱이 완료 후에 스크립트를 로드함
- DOM을 직접 조작하는 스크립트에 적합함

### CORS와 외부 스크립트

외부 스크립트를 사용할 때는 `CORS 정책`을 이해해야 함

- `CORS (Cross-Origin Resource Sharing 엄청 기네)`는 외부 리소스 로드 시 보안과 관련된 제약을 설정함
- 예를 들어, 외부 CDN에서 스크립트를 로드할 경우 `crossorigin` 속성이 필요할 수 있다함

```javascript
<script src="https://example.com/library.js" crossorigin="anonymous"></script>
```

## 엄격 모드

### 언제 쓰는거임?

엄격 모드는 [Javascript Info 문서](https://ko.javascript.info/strict-mode)에서 보았을 때, 자바스크립트가 발전하면서 새로운 기능이 추가되고 기존 기능이 변경되면서 호환성 문제가 생긴 것을 해결하기 위해 도입되었다.

기본적으로 자바스크립트는 역호환성을 중요시하기 때문에, 기존 코드와 충돌하지 않도록 엄격 모드는 선택적으로 적용할 수 있으며, 더 안전하고 예상 가능한 코드를 작성하고 싶을 때 엄격 모드를 사용하는 것이 권장된다.

#### 엄격 모드를 사용하는 주요 상황

- `새 프로젝트를 시작할 때`
  - 새로운 프로젝트에서는 코드의 안정성과 품질을 위해 엄격 모드를 기본으로 적용하는 것이 좋다.
  - 리액트, 넥스트.js 같은 프레임워크도 <u>기본적으로 이를 지원</u>한다.
- `실수를 예방하고 싶은 경우`
  - 엄격 모드는 암묵적인 전역 변수 선언, 중복된 매개변수 이름, 잘못된 this 바인딩과 같은 일반적인 실수를 방지한다.
  - 이는 특히 초보 개발자나 팀 프로젝트에서 유용하다.
- `레거시 코드를 리팩토링할 때`
  - 레거시 코드에서 더 안전하고 유지보수하기 쉬운 코드를 작성하기 위해 일부 모듈이나 파일에만 엄격 모드를 단계적으로 적용할 수 있다.
- `브라우저 최적화`
  - 최신 자바스크립트 엔진은 엄격 모드로 작성된 코드를 더 잘 최적화한다.
  - 성능 향상이 필요한 경우 엄격 모드를 사용하는 것이 유리할 수 있다.
- `코드 품질 도구와 함께 사용할 때`
  - ESLint와 같은 정적 분석 도구를 사용하는 환경에서 엄격 모드와 함께 사용하면, 잠재적인 오류를 더 효과적으로 탐지할 수 있다.

### 그럼 필수인걸까?

필수는 아니다. 자바스크립트에서 선택적으로 사용할 수 있으며, 비엄격 모드와 호환되게 설계되어있다. 리액트와 넥스트 같은 프레임워크에서는 기본적으로 엄격 모드를 권장하거나 활성화하는걸 추천함

## 변수와 상수

### 좋은 변수 이름을 사용해야 하는 이유?

먼저 `표기법`에 대해 생각해보면, 가장 많이 사용하던 것은 `camelCase`였던 것 같다. 다른 표기법은 종종 보았지만 이는 팀의 컨벤션에 따라 달라질 것 같아서 크게 생각은 안하고 있었다. 하지만 <u>표기법과 변수의 이름은 코드의 `가독성`, `유지보수성`에 큰 영향</u>을 미친다.<br/><br/> 이와 같이 규칙이 생겨난 이유는 역시 **같이 일하기 때문**이 아닐까 싶다. 혼자 개발할꺼면 뭐 규칙이 뭔 소용이 있나 자기만 잘 이해하면 될 것이지~ 하지만 같이 개발을 한다면 서로가 <u>이해하기 쉽게 작성하지 않으면</u> 스트레스와 피로감이 상당할 거고 이는 프로젝트 컨디션에 영향이 클 것이다. 아래는 가이드라인에 대해 조사해봤다.

#### 의미 있는 이름을 사용하셈

변수 이름만 봐도 어떤 값을 담고 있는지 알 수 있도록 작성해야한다.

```javascript
let count = 100; // 무슨 카운트잉교..
let userCount = 100; // ㅇㅋ
```

#### 일관된 표기법을 사용하셈

지금까지 다른 케이스는 보질 못했는데, 그렇단 것이 아마 대부분 이렇게 사용하지 않을까 싶다

- `camelCase`: 일반적으로 변수와 함수 이름에 사용함
- `UPPER_CASE`: 상수나 환경 변수에 사용함
- `snake_case`: 파일명이나 특정 팀 컨벤션에 따라 사용함

```javascript
const MAX_USER = 100; // 상수
let userName = "rarrit"; // 변수
```

#### 불필요한 약어와 줄임말은 지양하셈

쓴 사람만 알 확률이 큼. 이해하기 어렵게 쓰면 노노핑이다.

```javascript
let usrCnt = 100; // ?
let userCount = 100; // ㅇㅋ
```

#### 길이도 신경 쓰면 좋음

변수의 이름이 너무 짧거나 너무 긴 것도 별로임 (그래서 너무 어려움..) 간결하고 의미를 담으면 best!

```javascript
let ct; // 멍미
let campingUserCurrent머시기머시기; // 너무 긺
```

## 자료형

### 자료형의 종류

- `원시 타입`
  - **Number(숫자형)**: 정수, 부동 소수점 숫자 등의 숫자를 나타낼 때 사용함 (정수의 한계는 ±253)
  - **BigInt**: 길이 제약 없이 정수를 나타낼 수 있음
  - **String(문자형)**: 빈 문자열이나 글자들로 이뤄진 문자열을 나타낼 때 사용함
  - **Boolean(불린형)**: true, false를 나타낼 때 사용함
  - **null**: null 값만을 위한 독립 자료형임. (null은 알 수 없는 값을 나타냄)
  - **undefined**: undefined 값만을 위한 독립 자료형임. (undefined는 할당되지 않은 값을 나타냄)
  - **Symbol(심볼형)**: 객체의 고유 식별자를 만들 때 사용함
- `참조 타입`
  - **Object(객체형)**: 복잡한 데이터 구조를 표현할 때 사용함

### 원시, 참조 자료형의 차이

원시 자료형은 값 자체를 복사하지만, 참조 자료형은 메모리 주소를 참조한다는 차이를 이해해야한다.

#### 원시 자료형의 예시

- `a`는 값 `10`을 저장하고 있음
- `b = a`는 `a`의 값을 복사하여 `b`에 저장함
- `b`의 값을 변경해도 `a`의 값은 **영향을 받지 않음**
- 영향을 받지 않는 이유는 <u>원시 자료형이 값 자체를 복사</u>하기 때문이다.

```javascript
let a = 10;
let b = a; // a값을 b에 저장
b = 20;

console.log(a); // 10
console.log(b); // 20
```

#### 참조 자료형의 예시

- `obj1`은 객체의 메모리 주소를 참조한다.
- `obj2 = obj1`은 `obj1`의 주소값을 `obj2`에 복사한다.
- 따라서 `obj2`를 통해 객체를 수정하면 `obj1`도 동일한 객체를 참조하기 때문에 **영향을 받는다.**
- 영향을 받는 이유는 <u>자료형이 메모리 주소를 참조</u>하기 때문입니다.

#### 참조 자료형은 그럼 어떻게 복사해?

참조 자료형의 복사 문제를 해결하기 위해 `얕은 복사`와 `깊은 복사` 방법을 사용하면 된다. 이는 이전에 [JavaScript의 얕은 복사, 깊은 복사](https://rarrit.github.io/til/js/js-copy/) 글을 작성했었는데, 요약하자면 아래와 같다.

- `얕은 복사`는 1차 속성만을 복사한다. 즉, 중첩된 객체는 배열은 여전히 원본 객체와 참조를 공유함 (Spread 연산자)
- `깊은 복사`는 객체의 모든 계층을 재귀적으로 복사하여 완전히 새로운 객체를 생성한다. 중첩된 객체도 독립저긍로 복사되기 때문에 원본 객체와 완전히 분리된다. (JSON 방식)

### 심볼 타입을 본 적이 있음?

솔직히 심볼타입은 한번도 못본 것 같다. 사용법은 아래와 같다.

```javascript
const id = Symbol("id"); // 고유한 심볼 생성
const user = {
  name: "rarrit",
  [id]: 1234, // 심볼을 프로퍼티 키로 사용
};

console.log(user[id]); // 1234
console.log(user); // { name: "rarrit" }
```

`Symbol`은 항상 고유하므로, 다른 코드나 라이브러리에서 같은 키를 사용해도 충돌하지 않는다. 그런데, `심볼을 잘 안쓰는 이유`는 무엇인지 알아보자면 아래와 같다.

1. 대체 기능의 존재: 대부분의 경우, 심볼 대신 문자열이나 변수로 해결 가능함
2. 가독성 문제: 심볼은 익숙하지 않은 개발자에게 이해하기 어렵고, 디버깅 시 문자열처럼 확인이 쉽지 않음

못본 이유가 있다.

## 형 변환

### 암시적 형 변환

자바스크립트는 다양한 데이터 타입 간의 호환성을 보장하기 위해 자동으로 타입을 변환한다. 하지만 이 과정이 예상치 못한 결과를 초래할 수 있다.

#### 문자열과 숫자의 연산

1. string + number = string
2. string - number = number
3. string \* number = number
4. string / number = number
5. string % number = number

```javascript
"5" + 2; // "52"
"5" - 2; // 3
"5" * "2"; // 10
"10" / 2; // 5
"10" % 3; // 1
```

#### 불리언과 숫자

`true`는 1 `false`는 0으로 계산된다.

```javascript
true + 1; // 2
false - 1; // -1
```

#### Falsy와 Truthy 값

1. if(0) -> `false`
2. if("") -> `false`
3. if("hello") -> `true`

### 명시적 형 변환

명시적 형 변환은 의도적으로 값을 특정 데이터 타입으로 변환한다.

#### 숫자로 변환

자주 사용했던 건 `Number`와 `parseInt` 였던 것 같다.

```javascript
Number("123"); // 123
+"123"; // 123
parseInt("123px"); // 123
```

#### 문자열로 변환

`Number`와 마찬가지로 `String`을 자주 사용했는데, `toString`이 더 많이 사용하는 것 같은..

```javascript
String(123); // "123"
(123).toSTring(); // "123"
```

#### 불리언으로 변환

사용하지도 않았고 본 적도 없는데 불리언을 사용할 때 주로 if문을 사용해서가 아닐까.. 싶은

```javascript
Boolean(1); // true
Boolean(0); // false
Boolean("hello"); // true
Boolean(""); // false
```

### :three: 형 변환 주요 메서드

자주 사용했던 기억이 없는데, 찾아보다가 있어서 정리해봤다.

#### `JSON.stringify()`와 `JSON.parse()`

객체를 문자열로, 문자열을 다시 객체로 변환하는 방법이다.

```javascript
const obj = { key: "value" };
const str = JSON.stringify(obj); // '{"key" : "value"}'
const parsed = JSON.parse(str); // {key: "value"}
```

#### `isNaN()`과 `Number.isNaN()`

- `isNaN()`은 형 변환 후 체크함
- `Number.isNaN()`은 정확히 NaN인 경우만 체크함

```javascript
isNaN("123abc"); // true
Number.isNaN("123abc"); // false
```

#### `typeof`와 `instanceof`의 차이

- `typeof`는 데이터 타입 확인
- `instanceof`는 특정 객체인지 확인

```javascript
typeof []; // "object"
[] instanceof Array; // true
```

#### :pushpin: 3-4) `Object.prototype.toString()`

- 객체의 정확한 타입을 확인하는 방법이다.

```javascript
Object.prototype.toString.call([]); // [object Array]
Object.prototype.toString.call({}); // [object Object]
```

### 자주 겪는 실수

형 변환에서 헷갈리는 부분을 정리해봤다.

#### `null`과 `undefined`의 특성

```javascript
null == undefined; // true
null === undefined; // false
```

#### 배열과 객체

실제로 사용해보거나 본 적은 없는데 엥? 해서 가져옴

```javascript
[1, 2] == "1,2"; // true 엥?
[] == ""; // true
{
}
+{}; // NaN(런타임 상황에 따라 다르다함) 이건 무ㅓ..?
```

#### `NaN`의 특성

`NaN`은 웃긴게 서로도 같지 않음

```javascript
NaN === NaN; // false
```

## if와 '?'를 사용한 조건 처리

### if문: 가독성이 중요한 다중 조건 로직

- 조건이 복잡하거나, **여러 명령문**을 실행해야 할 때 적합하다.
- 코드 가독성과 명확성이 중요한 상황에서 유리하다.

### 삼항 연산자: 짧고 간결한 조건

- 단순한 조건과 **단일 표현식**이 있을 때 적합하다.
- 짧고 간결한 코드 작성에 유리하다.

### 차이점 비교

| 특징             | if 문                                   | 삼항 연산자                                     |
| ---------------- | --------------------------------------- | ----------------------------------------------- |
| 가독성           | 복잡한 조건과 여러 명령문에서 더 명확   | 간단한 조건에 적합, 길어지면 오히려 가독성 저하 |
| 표현식 가능 여부 | 표현식으로 사용할 수 없음 (return 필요) | 표현식으로 사용할 수 있어 변수에 바로 할당 가능 |
| 다중 조건 처리   | else if를 활용해 여러 조건 처리 가능    | 다중 조건은 중첩되어 가독성을 해칠 수 있음      |

### 언제 무엇을 사용함?

#### if문을 사용하는 상황

- 명령문이 여러 개인 경우

```javascript
if (user.isLoggedIn) {
  console.log("로그인 성공함");
  redirectToDashboard();
}
```

- 조건이 복잡하거나 다단계인 경우

```javascript
if (age < 13) {
  console.log("어린이");
} else if (age < 20) {
  console.log("청소년");
} else {
  console.log("성인");
}
```

#### 삼항 연산자를 사용하는 상황

- 단일 값의 반환 또는 할당이 필요한 경우

```javascript
const isAdult = age >= 18 ? true : false;
```

- UI 컴포넌트에서 간단한 조건부 렌더링

```javascript
return isLoggedIn ? <Dashboard /> : <Login />;
```

### 요약

| 조건 처리 복잡도 | 적합한 방식 | 설명                                     |
| ---------------- | ----------- | ---------------------------------------- |
| 간단한 조건      | 삼항 연산자 | 단순한 조건의 표현식에 적합              |
| 복잡한 조건      | if 문       | 가독성과 유지보수를 위해 if 문이 더 적합 |
| 다중 명령문 처리 | if 문       | 여러 명령문 실행이 필요할 때             |
| 단일 값 반환     | 삼항 연산자 | 짧고 간결하게 조건부 값 반환 가능        |

## nullish 병합 연산자 '??'

### nullish 병합 연산자란?

`??`는 `null` 또는 `undefined`를 확인하고, 값이 없을 때 기본값을 반환하는 연산자다. 즉, 값이 `null`이거나 `undefined`일 경우에만 오른쪽 값을 반환한다. 아래의 기본 문법을 보자.

```javascript
let result = a ?? b;
```

- `a`가 `null` 또는 `undefined`일 경우 `b`를 반환함
- `a`가 그 외의 값일 경우 `a`를 반환함

### 그럼 언제 사용될까?

#### 기본값 설정

변수의 값이 없을 경우 기본값을 설정할 때 유용하다.

```javascript
const userName = null;
const defaultName = "Guest";

const nameToDisplay = userName ?? defaultName;
console.log(nameToDisplay); // "Guest"
```

#### 함수 매개변수의 기본값 처리

함수 호출 시, 인자가 없거나 `undefined`일 경우 기본값을 설정한다.

```javascript
function greet(name) {
  const greetingName = name ?? "Anonymous";
  console.log(`Hello, ${greetingName}!`);
}
greet(); // "Hello, Anonymous!"
greet("Rarrit"); // "Hello, Rarrit!"
```

#### 데이터 읽을때 값 확인

데이터 객체에서 값이 없는 경우 기본값을 설정할 때 활용한다.

```javascript
const userSettings = {
  theme: null,
};
const theme = userSettings.theme ?? "black";
console.log(theme); // "black"
```

### 중첩 `??` 연산자

`??` 연산자는 중첩해서 사용할 수 있다.

```javascript
const value = null ?? undefined ?? "default" ?? "anther Default";
console.log(value);
("default");
```

## while문과 for 반복문

### 두 반복문의 차이점 비교

| 특징             | while 문                                                    | for 문                                     |
| ---------------- | ----------------------------------------------------------- | ------------------------------------------ |
| 사용 목적        | 조건에 따라 반복, 반복 횟수를 알 수 없을 때                 | 반복 횟수가 명확할 때                      |
| 가독성           | 조건만으로 반복을 정의 (간결하지만 가독성이 떨어질 수 있음) | 초기값, 조건, 증감식을 한 줄로 관리 가능   |
| 사용 예          | 사용자 입력, 데이터 처리, 무한 루프 등                      | 정해진 범위 순회, 배열 및 객체 데이터 처리 |
| 무한 루프 가능성 | 조건을 잘못 설정하면 무한 루프 발생 가능                    | 조건이 명확하여 무한 루프 가능성이 낮음    |

### 언제 어떤 것을 사용할까?

| 상황                                  | 적합한 반복문 | 설명                                                        |
| ------------------------------------- | ------------- | ----------------------------------------------------------- |
| 조건에 따라 동적 반복이 필요할 때     | while         | 반복 횟수를 예측하기 어렵거나 종료 조건이 동적일 때 사용    |
| 정해진 범위나 횟수의 반복이 필요할 때 | for           | 초기값, 조건, 증감식이 명확한 경우 적합                     |
| 데이터 스트림이나 사용자 입력 처리 시 | while         | 데이터가 지속적으로 들어오거나 사용자 입력을 기다릴 때 적합 |
| 배열, 객체 등의 데이터를 순회할 때    | for           | 반복 가능한 데이터 구조를 다룰 때 간결하게 작성 가능        |

## switch 문

### switch 문과 if-else 문의 차이

| 특징           | switch 문                              | if-else 문                                 |
| -------------- | -------------------------------------- | ------------------------------------------ |
| 비교 방식      | 동일한 값 비교 (===)                   | 다양한 조건 (범위, 논리 연산 등) 사용 가능 |
| 가독성         | 조건이 많을수록 읽기 쉽고 명확         | 조건이 많아지면 가독성이 떨어질 수 있음    |
| 유연성         | 제한된 값 비교에 적합                  | 범위 비교,복잡한 논리가 필요한 경우 적합   |
| 기능 확장성    | case를 추가하거나 수정하기 쉽고 간단함 | 조건이 복잡할 경우 더 자유롭게 설정 가능   |
| 중첩 조건 처리 | 한정된 방식으로 처리 가능 (case 중첩)  | 다양한 조건을 중첩하여 설정 가능           |

### 언제 switch 문을 사용할까?

| 상황                                    | 적합한 선택 | 이유                                 |
| --------------------------------------- | ----------- | ------------------------------------ |
| 조건 값이 명확하고 고정된 경우          | switch      | 가독성이 좋고, 추가 및 수정이 용이함 |
| 조건 값이 복잡하거나 범위가 필요한 경우 | if-else     | 다양한 논리와 조건 처리에 적합       |

## 함수

### 함수 네이밍: 명확 간결!

함수 이름은 무엇으로 할까?

- 함수가 수행하는 동작을 명확히 나타내야 한다.
- 간결하면서도 의미를 담아야 한다. 코드를 읽는 사람은 함수 이름만 보고 함수의 역할을 이해할 수 있어야 한다.

#### 동작을 나타내는 동사 접두어을 사용해보자.

함수 이름은 대개 동사로 시작하며, 아래와 같은 접두어를 사용할 수 있다.

- `get..`: 값을 반환 (getAge: 나이를 반환)
- `calc..`: 계산 수행 (calcSum(): 함계를 계산)
- `create..`: 무언가를 생성 (createForm(): 폼을 생성)
- `check..`: 조건 확인 (checkPermission(): 권한 확인)

접두어를 적절히 활용하여 이름만으로 함수의 동작과 반환값을 유추할 수 있어 코드의 가독성이 크게 향상된다.

### 함수는 단일 책임을 가져야 한다.

**"하나의 함수, 하나의 동작"**<br/> 함수는 이름에 명시된 동작 하나만 수행해야한다. 여러 동작을 동시에 수행하지 않도록 주의하자!

- `getAge()`는 나이 반환만 해야 하며, 메시지 출력은 포함되지 않아야 한다.
- `createForm()`은 폼 생성만 수행하며, 생성된 폼을 DOM에 추가하는 작업은 다른 함수에서 처리해야 한다.

### 함수 이름으로 주석의 역할을 대신하라

- 함수 이름이 명확하면 주석 없이도 코드를 이해할 수 있다.
- 함수를 짧게 작성하면 디버깅과 테스트가 쉬워진다.

### 매개변수와 외부 변수

- 함수는 매개변수와 지역 변수만 활용하여 동작해야 한다.
- 외부 변수에 의존하는 함수는 이해하기 어렵고, 재사용성이 떨어진다.

### 요약

1. 함수 이름은 동사를 포함하여 명확히 동작을 나타내야 한다.
2. 접두어(get, create, check, calc)를 사용하면 함수의 역할을 쉽게 알 수 있다.
3. 단일 책임 원칙을 지켜, 함수는 하나의 동작만 수행해야 한다.
4. 긴 함수는 분리하여 간결하고 읽기 쉬운 코드를 만들자.
5. 매개변수와 지역 변수를 사용하고, 외부 변수 의존성을 줄이자.

## 함수 선언식, 표현식, 화살표 함수

### 함수 선언식 (Function Declaration)

함수 선언식은 function 키워드를 사용하여 독립적인 형태로 함수를 정의하는 방식이다.

- 호이스팅: 함수 선언식으로 정의된 함수는 스코프의 맨 위로 끌어올려져 호출 시점보다 선언 시점이 뒤에 있어도 호출이 가능함.
- 가독성: 함수 이름이 명확하게 드러나므로 코드의 의도를 쉽게 파악할 수 있음.

```javascript
// 문법
function 함수이름(매개변수1, 매개변수2) {
  // 함수 본문
  return 값;
}
```

#### 사용 시점

- 함수가 코드 내에서 독립적이고 반복적으로 사용될 때.
- 함수가 상단에 선언되더라도 호출되는 시점에 문제가 없을 때.

### 함수 표현식 (Function Expression)

함수 표현식은 변수에 익명 함수 또는 이름을 가진 함수를 할당하는 방식이다.

- 호이스팅: 함수 표현식은 선언 전에 호출할 수 없다. 이는 함수가 변수에 할당되기 전까지 사용할 수 없기 때문
- 익명 함수: 일반적으로 이름이 없는 함수(익명 함수)를 사용하지만, 필요에 따라 이름을 명시할 수도 있다.

```javascript
// 문법
const 변수이름 = function (매개변수1, 매개변수2) {
  // 함수 본문
  return 값;
};
```

#### 사용 시점

- 함수가 특정 변수에 저장되거나, 다른 함수의 인자로 전달될 때.
- 함수 선언 순서와 호출 순서를 엄격히 관리해야 할 때.

### 화살표 함수 (Arrow Function)

화살표 함수는 ES6에서 도입된 간결한 함수 작성 방식이다.

- this 바인딩 없음: 화살표 함수는 자신만의 this를 가지지 않고, 선언된 위치의 this를 상속받는다. 따라서 객체 메서드로 사용하기에는 적합하지 않음
- 간결한 문법: 본문이 한 줄이면 {}와 return 키워드를 생략할 수 있다.
- 익명 함수: 항상 이름이 없는 함수로 사용된다.

```javascript
// 문법
const 변수이름 = (매개변수1, 매개변수2) => {
  // 함수 본문
  return 값;
};
```

#### 사용 시점

- 콜백 함수나 간결한 연산을 수행하는 함수에 적합.
- this를 상속받아야 하는 경우.

### 세 가지 방식의 비교

| 특징        | 함수          | 선언식 함수        | 표현식 화살표 함수 |
| ----------- | ------------- | ------------------ | ------------------ |
| 호이스팅    | 지원됨        | 지원되지 않음      | 지원되지 않음      |
| this 바인딩 | 고유 바인딩   | 고유 바인딩        | 상위 스코프 상속   |
| 문법 간결성 | 일반적        | 일반적             | 매우 간결          |
| 사용 시점   | 독립적인 함수 | 변수에 할당된 함수 | 콜백, 간단한 함수  |

### 요약

일반적으로 함수를 선언해야 한다면 함수가 선언되기 이전에도 함수를 활용할 수 있기 때문에, 함수 선언문 방식을 따르는 게 좋다. 함수 선언 방식은 코드를 유연하게 구성할 수 있도록 해주고, 가독성도 좋기 때문이다.

- `함수 선언식`: 호이스팅이 필요하고 독립적인 역할을 하는 함수에 적합하다.
- `함수 표현식`: 변수와 결합하거나 동적으로 함수를 정의할 때 사용한다.
- `화살표 함수`: 콜백 함수나 간결한 함수 작성에 유용하며, this를 상속받아야 하는 경우 사용한다.
- 가독성이 중요한 경우: `함수 선언식`
- 동적으로 함수를 정의해야 하는 경우: `함수 표현식`
- 간단한 로직이나 콜백: `화살표 함수`
